<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Music Week Archive</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lucide/0.263.1/umd/lucide.min.js"></script>
    <style>
        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-dark: #121212;
            --text-primary: #212529;
            --text-secondary: #495057;
            --border-color: #dee2e6;
            --accent-color: #000000;
            --accent-hover: #1a202c;
            --card-shadow: rgba(0, 0, 0, 0.1);
            --accent-pop: #E3836D;

        }
        .grid {
    background: var(--bg-primary);
    border-radius: 8px;
    display: grid;
    gap: 16px;
    padding: 16px;
    grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
}
.btn-view-tracks {
    background: #DE846C !important;
    color: white !important;
    border: none !important;
    padding: 8px 16px !important;
    border-radius: 6px !important;
    cursor: pointer !important;
    font-size: 12px !important;
    font-weight: 600 !important;
    transition: all 0.2s;
}

.btn-view-tracks:hover {
    background: #c97456 !important;
}

.card {
    background: var(--bg-secondary);
    border-radius: 8px;
    overflow: hidden;
    border: 2px solid transparent;
    transition: all 0.2s;
    cursor: pointer;
    text-decoration: none;
    color: inherit;
    display: flex;
    flex-direction: column;
}

.card, .card * {
    text-decoration: none !important;
}

.card:hover {
    border-color: #E3836D;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    transform: translateY(-2px);
}

.card-image {
    width: 100%;
    aspect-ratio: 1;
    background: var(--accent-color);
    display: flex;
    align-items: center;
    justify-content: center;
    color: #9ca3af;
    position: relative;
    margin-bottom: 8px;
}

.card-image img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.card-overlay {
    position: absolute;
    inset: 0;
    background: rgba(0,0,0,0);
    display: none;
    justify-content: center;
    align-items: center;
    opacity: 0;
    transition: all 0.2s;
}

.card:hover .card-overlay {
    background: rgba(0,0,0,0);
    opacity: 0;
}

.open-link {
    display: none;
}

.card-info {
    padding: 12px 12px 12px 0;
    line-height: 1.2;
}

.card-title {
    color: var(--text-primary);
    font-size: 0.875rem;
    font-weight: 600;
    margin-bottom: 2px;
}

.card-creator {
    color: var(--text-secondary);
    font-size: 0.75rem;
    margin-bottom: 2px;
}

.card-year {
    color: var(--text-secondary);
    font-size: 0.75rem;
    margin-bottom: 0;
}

.card-contributor-names {
    color: var(--text-secondary);
    font-size: 0.75rem;
    margin-bottom: 2px;
}

.card-contributor-badges-overlay {
    position: absolute;
    top: 8px;
    right: 8px;
    display: flex;
    gap: 4px;
    flex-wrap: wrap;
    justify-content: flex-end;
}
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #ffffff;
            min-height: 100vh;
	    margin: 0;
            padding: 0px;
            transition: background-color 0.3s, color 0.3s;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: var(--bg-primary);
            color: var(--text-primary);
            border-radius: 0px;
            box-shadow: none;
            overflow: hidden;
            transition: background-color 0.3s, color 0.3s;
        }
        .header {
            background: white;
            color: var(--text-primary);
            padding: 30px 40px;
            text-align: left;
            position: relative;
            border-bottom: 1px solid var(--border-color)
        }
        
        @media (max-width: 480px) {
            .header {
                padding: 16px 12px;
            }
        }
        .header h1 {
            font-size: 28px;
            margin-bottom: 5px;
            color: var(--text-primary);

        }
        .header p {
            opacity: 0.6;
            font-size: 14px;
            color: var(--text-secondary);

        }
        .content {
            padding: 30px 40px;
            background: var(--bg-primary);
            transition: background-color 0.3s;
        }
        
        @media (max-width: 480px) {
            .content {
                padding: 16px 12px;
            }
        }
        .icon {
            width: 20px;
            height: 20px;
            stroke: currentColor;
            fill: none;
            display: inline-block;
            vertical-align: middle;
            margin-right: 8px;
            flex-shrink: 0;
        }

        .tab svg {
            stroke: var(--text-secondary);
            transition: stroke 0.3s;
        }

        .tab:hover svg {
            stroke: var(--text-primary);
        }

        .tab.active svg {
                stroke: var(--accent-color);
        }

/* Mobile menu toggle button */
.mobile-menu-btn {
    display: none;
    background: transparent;
    border: none;
    padding: 8px;
    border-radius: 6px;
    cursor: pointer;
    color: var(--text-primary);
    align-items: center;
    justify-content: center;
    white-space: nowrap;
    flex-shrink: 0;
    transition: all 0.2s;
    order: -1;
    margin-right: auto;
}

.mobile-menu-btn:hover {
    background: #f3f4f6;
}

.mobile-menu-btn svg {
    width: 20px;
    height: 20px;
    stroke: currentColor;
    stroke-width: 2;
}

.mobile-menu-label {
    display: none;
    margin-left: 8px;
    font-weight: 600;
    color: var(--text-primary);
    font-size: 15px;
    transition: transform 0.22s cubic-bezier(.2,.9,.2,1), opacity 0.18s ease;
    transform-origin: left center;
    will-change: transform, opacity;
}

.mobile-menu-wrap {
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: flex-start;   /* keeps button locked in place (left aligned) */
    position: relative;
    z-index: 5;
}

/* Ensure the button inside the wrap doesn't push the label away */
.mobile-menu-wrap .mobile-menu-btn {
    order: 0;
    margin-right: 0;
}

.mobile-menu-btn svg {
    transition: transform 0.2s ease;
    transform-origin: center;
}

.mobile-menu-btn.open svg {
    transform: rotate(180deg);
}

/* Desktop: Show text labels instead of icons */
@media (min-width: 769px) {
     th.header-icon {
        padding: 12px 15px !important;
    }
    
    th.header-icon .icon-only {
        display: none;
    }
    
    th.header-icon .text-only {
        display: block;
    }
}

/* Mobile: Show icons */
@media (max-width: 768px) {
    /* Mobile: Show icons, hide text, add tooltips */
th.header-icon {
    cursor: pointer;
    user-select: none;
    padding: 8px 4px !important;
}

th.header-icon .text-only {
    display: none;
}

th.header-icon .icon-only {
    display: block;
}

th.header-icon svg {
    width: 20px;
    height: 20px;
    display: block;
    margin: 0 auto;
    stroke: var(--text-secondary);
}

th.header-icon:hover svg {
    stroke: var(--text-primary);
}
}
@media (max-width: 480px) {
/* Contributors table mobile card layout */
#contributors-table {
    width: 100% !important;
    max-width: 100% !important;
    border-collapse: separate;
    border-spacing: 0;
    font-size: 11px;
}

#contributors-table thead {
    display: none;
}

#contributors-table tbody {
    display: block;
}

#contributors-table tbody tr {
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-gap: 10px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    margin-bottom: 12px;
    padding: 10px;
    background: var(--bg-secondary);
    cursor: pointer;
    transition: all 0.2s;
}

#contributors-table tbody tr:hover {
    background: rgba(222, 132, 108, 0.08);
    box-shadow: inset 3px 0 0 #DE846C;
}

/* TOP ROW: Span full width */
#contributors-table tbody tr td:nth-child(1) {
    grid-column: 1 / -1;
    display: flex;
    align-items: center;
    gap: 8px;
    border: none;
    padding: 0;
    margin: 0;
}

/* TOP RIGHT: Tracks and Pct (full width, right aligned) */
#contributors-table tbody tr td:nth-child(2),
#contributors-table tbody tr td:nth-child(3) {
    grid-column: 1 / -1;
    text-align: right;
    border: none;
    padding: 0;
    margin: 0;
    font-size: 11px;
    font-weight: 600;
    color: var(--text-primary);
}

#contributors-table tbody tr td:nth-child(2)::before {
    content: "Tracks: ";
    font-weight: 400;
    color: #666;
    font-size: 9px;
    margin-right: 4px;
}

#contributors-table tbody tr td:nth-child(3)::before {
    content: "Pct: ";
    font-weight: 400;
    color: #666;
    font-size: 9px;
    margin-right: 4px;
}

/* LEFT COLUMN: Top Genre and Niche Genre */
#contributors-table tbody tr td:nth-child(5),
#contributors-table tbody tr td:nth-child(6) {
    grid-column: 1;
    display: block;
    border: none;
    padding: 0;
    margin: 0;
    font-size: 10px;
    color: #666;
    word-break: break-word;
    overflow-wrap: anywhere;
    line-height: 1.4;
}

/* RIGHT COLUMN: Top Artist and Years */
#contributors-table tbody tr td:nth-child(4),
#contributors-table tbody tr td:nth-child(7) {
    grid-column: 2;
    display: block;
    border: none;
    padding: 0;
    margin: 0;
    font-size: 10px;
    color: #666;
    word-break: break-word;
    overflow-wrap: anywhere;
    line-height: 1.4;
}

/* Add labels */
#contributors-table tbody tr td:nth-child(4)::before {
    content: "Top Artist: ";
    font-weight: 600;
    color: var(--text-primary);
}

#contributors-table tbody tr td:nth-child(5)::before {
    content: "Top Genre: ";
    font-weight: 600;
    color: var(--text-primary);
}

#contributors-table tbody tr td:nth-child(6)::before {
    content: "Niche Genre: ";
    font-weight: 600;
    color: var(--text-primary);
}

#contributors-table tbody tr td:nth-child(7)::before {
    content: "Years: ";
    font-weight: 600;
    color: var(--text-primary);
}

/* Contributor badge sizing on mobile */
#contributors-table .contributor-display {
    display: flex;
    align-items: center;
    gap: 8px;
}

#contributors-table .contributor-badge {
    width: 32px;
    height: 32px;
    font-size: 11px;
    padding: 0;
    flex-shrink: 0;
    display: inline-flex;
    align-items: center;
    justify-content: center;
}

#contributors-table .contributor-display .name {
    font-size: 12px;
    font-weight: 600;
}
}
/* Hide tabs on mobile */
@media (max-width: 768px) {
    .tabs {
        display: none !important;
    }
    
    .mobile-menu-btn {
        display: flex !important;
    }

    /* Make the mobile menu control look like a clear action button */
    .mobile-menu-btn {
        background: var(--accent-pop);
        color: white;
        padding: 8px 12px !important;
        border-radius: 10px !important;
        border: 1px solid rgba(0,0,0,0.04) !important;
        box-shadow: 0 2px 6px rgba(0,0,0,0.08);
        align-items: left;
        gap: 8px;
        width: 100%;
    }

    .mobile-menu-btn svg { stroke: white; }

    /* Lighter, more neutral button style and internal label for clarity */
    .mobile-menu-btn {
        background: #f3f4f6 !important;
        color: var(--text-primary) !important;
        padding: 8px 12px !important;
        border-radius: 10px !important;
        border: 1px solid var(--border-color) !important;
        box-shadow: none !important;
        align-items: center;
        gap: 8px;
    }

    .mobile-menu-btn svg { stroke: var(--text-primary); }

    .mobile-menu-btn:hover { background: #F7F0EE !important; }

    .mobile-menu-btn:focus { outline: none; box-shadow: 0 0 0 4px rgba(16,24,32,0.06); }

    /* Keep open state subtle */
    .mobile-menu-btn.open { background: #e9e9ea !important; }

    /* Use in-button text element for precise alignment */
    .mobile-menu-btn::after { content: none; }
    .mobile-menu-btn .mobile-menu-btn-text {
        display: inline-block;
        margin-left: 8px;
        font-weight: 600;
        color: var(--text-primary);
        font-size: 15px;
        line-height: 1;
    }

    .mobile-menu-label { display: none; }
    /* Alignment overrides: make icon and text match dropdown menu items
       — keep button full-width so it reads as the menu bar */
    .mobile-menu-btn {
        width: 100% !important;
        padding-left: 14px !important; /* match .dropdown-menu button left padding */
        padding-right: 16px !important; /* match dropdown right padding */
        display: flex !important;
        justify-content: flex-start !important;
        align-items: center !important;
    }

    .mobile-menu-btn svg {
        width: 18px !important;
        height: 18px !important;
        display: inline-block;
        vertical-align: middle;
    }

    .mobile-menu-btn .mobile-menu-btn-text { margin-left: 8px !important; }
    
    /* Add extra spacing under the menu bar on mobile so content doesn't sit flush */
    .mobile-menu-wrap {
        margin-bottom: 16px;
    }
    .dropdown-menu {
        border-top: 1px solid var(--border-color);
    }
    /* Tracks table: always fill available width and avoid horizontal scrolling */
    #tracks-table {
        width: 100% !important;
        max-width: 100% !important;
        font-size: 12px;
        border-collapse: collapse;
        table-layout: auto; /* let the browser distribute column widths */
    }

    #tracks-table th,
    #tracks-table td {
        padding: 6px 8px !important;
        vertical-align: middle;
        white-space: normal; /* allow wrapping */
        word-break: break-word;
        overflow-wrap: anywhere;
    }

    /* Small fixed column for rank */
    #tracks-table th:nth-child(1),
    #tracks-table td:nth-child(1) {
        width: 48px;
        padding: 6px 4px !important;
        text-align: center;
        font-size: 11px;
    }

    #tracks-table td:nth-child(1) {
        font-weight: 600;
    }

    /* Let the track name and artist take the remaining space; avoid hard min-widths */
    #tracks-table th:nth-child(2),
    #tracks-table td:nth-child(2) {
        width: auto;
    }

    #tracks-table th:nth-child(3),
    #tracks-table td:nth-child(3) {
        width: 35%;
        font-size: 13px;
    }

    #tracks-table th:nth-child(4),
    #tracks-table td:nth-child(4) {
        width: 20%;
    }

    /* Reduce contributor badge size on mobile/compact widths */
    #tracks-table .contributor-badge {
        width: 24px;
        height: 24px;
        font-size: 9px;
        padding: 0;
        display: inline-flex;
        align-items: center;
        justify-content: center;
    }

    /* Desktop: show full contributor names */
    #tracks-table .track-badge-desktop {
        display: inline-flex !important;
        width: auto;
        font-size: 10px;
        padding: 4px 8px;
    }

    #tracks-table .track-badge-mobile {
        display: none !important;
    }

    /* Mobile: show initials, hide full names when narrow */
    @media (max-width: 480px) {
        #tracks-table .track-badge-desktop {
            display: none !important;
        }

        #tracks-table .track-badge-mobile {
            display: inline-flex !important;
            width: 24px;
            height: 24px;
            font-size: 9px;
            padding: 0;
        }
    }
    /* Slide-and-fade the "Menu" label when the menu is open */
.mobile-menu-label {
    position: absolute;
    left: 40px;
    top: 50%;
    transform: translateY(-50%);
    transition: opacity .25s ease;
}

.mobile-menu-btn.open + .mobile-menu-label {
    opacity: 0;
}

    /* Add a bit of spacing below the menu button so it's not flush against following elements */
.mobile-menu-btn {
    margin-bottom: 12px;
}

.dropdown-menu {
    margin-bottom: 20px;
}
    /* show menu label next to icon on mobile */
    .mobile-menu-label {
        display: inline-block;
        margin-left: 8px;
        vertical-align: middle;
    }
}

/* Dropdown menu styles */
.dropdown-menu {
    width: 100%;
    background: var(--bg-primary);
    border-bottom: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    max-height: 0;
    transition: max-height 0.3s ease;
    position: relative;   /* ← important change */
}

.dropdown-menu.hidden {
    max-height: 0;
}
.dropdown-menu.open {
    max-height: 500px; /* big enough for all menu buttons */
}

.dropdown-menu:not(.hidden) {
    max-height: 600px;
}

.dropdown-menu button {
    width: 100%;
    text-align: left;
    padding: 14px 16px;
    border: none;
    background: transparent;
    color: var(--text-secondary);
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    gap: 8px;
    border-bottom: 1px solid var(--border-color);
}

.dropdown-menu button:last-child {
    border-bottom: none;
}

.dropdown-menu button:hover {
    background: #f3f4f6;
    color: var(--text-primary);
}

.dropdown-menu button.active {
    background: #f8c2b5;
    color: var(--accent-color);
    font-weight: 600;
}

.dropdown-menu svg {
    width: 18px;
    height: 18px;
    stroke: currentColor;
}

        .upload-section {
            background: var(--bg-secondary);
            border: 3px dashed var(--accent-color);
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            transition: all 0.3s;
        }
        .upload-section:hover {
            border-color: var(--accent-hover);
            background: var(--bg-secondary);
        }
        .upload-section input[type="file"] {
            display: none;
        }
        .upload-btn {
            background: var(--accent-color);
            color: white;
            padding: 15px 40px;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .upload-btn:hover {
            background: var(--accent-hover);
            transform: translateY(-2px);
        }
.tabs {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    border-bottom: 1px solid var(--border-color);
    margin-bottom: 30px;
    padding-left: 0;
    padding-right: 0;
    width: 100%;
    justify-content: center;
}
        .tab {
            padding: 10px 12px;
            background: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            transition: all 0.3s;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            white-space: nowrap;
        }
        .tab:hover {
            color: var(--accent-color);
        }
        .tab.active {
            color: var(--accent-color);
            border-bottom-color: var(--accent-color);
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }

/* modifies the Overview card spacing. when adjusting mobile v desktop later, don't change these widths*/

.stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 20px;
    margin-bottom: 30px;
}

@media (min-width: 1200px) {
    .stats-grid {
        grid-template-columns: repeat(6, 1fr);
    }
}

@media (min-width: 900px) and (max-width: 1199px) {
    .stats-grid {
        grid-template-columns: repeat(3, 1fr);
    }
}

@media (min-width: 600px) and (max-width: 899px) {
    .stats-grid {
        grid-template-columns: repeat(2, 1fr);
    }
}

@media (max-width: 599px) {
    .stats-grid {
        grid-template-columns: 1fr;
    }
}

.stat-card {
    background: #f8f9fa;
    color: var(--text-primary);
    padding: 25px;
    border-radius: 12px;
    text-align: center;
    border: 1px solid var(--border-color);
    box-shadow: none;
    transition: all 0.2s;
}

.stat-card:hover {
    background: rgba(222, 132, 108, 0.08);
    box-shadow: inset 0px 0 0 #DE846C;
}

.stat-number {
    font-size: 42px;
    font-weight: bold;
    margin-bottom: 10px;
    line-height: 1.2;
    word-break: break-word;
}
.stat-label {
    font-size: 14px;
    opacity: 0.9;
    text-transform: uppercase;
    letter-spacing: 1px;
    margin-top: 8px;
}

.stat-card.duration-card .stat-number {
    font-size: 32px;
    line-height: 1.3;
}
/* end of modifcations */
        .search-box {
            margin-bottom: 30px;
        }
        .search-box input {
            width: 100%;
            padding: 10px 15px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
            background: var(--bg-primary);
            color: var(--text-primary);
        }
        .search-box input:focus {
            outline: none;
            border-color: var(--accent-pop);
            box-shadow: 0 0 0 3px rgba(222, 132, 108, 0.1);
        }
        table {
            width: 100%;
            border-collapse: collapse;
            background: var(--bg-primary);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px var(--card-shadow);
        }
        th {
            background: #f8f9fa; 
            color: var(--text-secondary);
            padding: 12px 15px;
            text-align: left;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 11px;
            letter-spacing: 1px;
            border-bottom: 1px solid var(--border-color);

        }
        th.sortable {
            cursor: pointer;
            user-select: none;
            position: relative;
            padding-right: 25px;
        }
th.sortable:hover {
    background: #f0f1f3;
}
        th.sortable::after {
            content: '⇅';
            position: absolute;
            right: 8px;
            opacity: 0.5;
            font-size: 14px;
        }
        th.sortable.asc::after {
            content: '↑';
            opacity: 1;
        }
        th.sortable.desc::after {
            content: '↓';
            opacity: 1;
        }
        td {
            padding: 12px 15px;
            border-bottom: 1px solid var(--border-color);
            color: var(--text-primary);
            font-size: 14px;
        }
tr:hover {
    background: rgba(222, 132, 108, 0.08);
    box-shadow: inset 3px 0 0 #DE846C;
}

tr {
    transition: all 0.2s;
}
        .rank {
            font-weight: bold;
            color: var(--accent-color);
            font-size: 18px;
        }
        .loading {
            display: none;
            text-align: center;
            padding: 60px 20px;
        }
        .spinner {
            border: 4px solid var(--border-color);
            border-top: 4px solid var(--accent-color);
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .chart-container {
            background: var(--bg-primary);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px var(--card-shadow);
            margin-bottom: 30px;
        }
        .bar-chart {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .bar-item {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .bar-label {
            min-width: 150px;
            font-weight: 600;
            font-size: 14px;
            color: var(--text-primary);
        }
        .bar-wrapper {
            flex: 1;
            background: var(--bg-secondary);
            border-radius: 8px;
            overflow: hidden;
            height: 30px;
            position: relative;
        }
        .bar-fill {
            background: var(--accent-color);
            height: 100%;
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 10px;
            color: white;
            font-weight: bold;
            font-size: 12px;
        }
        .genres-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(380px, 1fr));
            gap: 20px;
        }
        
        @media (max-width: 768px) {
            .genres-grid {
                grid-template-columns: 1fr;
                gap: 16px;
            }
        }
        
        .genre-card {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 16px;
            transition: all 0.2s;
            cursor: pointer;
        }
        
        .genre-card:hover {
            box-shadow: 0 4px 12px var(--card-shadow);
            border-color: var(--accent-pop);
            transform: translateY(-2px);
        }
        
        .genre-card-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .genre-card-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .genre-card-name {
            font-size: 15px;
            font-weight: 700;
            color: #212529;
            line-height: 1.3;
            margin-bottom: 0px;
        }
        
        .genre-card-track-count {
            font-size: 13px;
            color: #666;
            font-weight: 500;
            line-height: 1.2;
            margin-top: 4px;
        }
        
        .genre-card-rank-section {
            padding-left: 16px;
            border-left: 1px solid #f0f0f0;
            text-align: right;
        }
        
        .genre-card-rank-label {
            font-size: 10px;
            color: #999;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .genre-card-rank-value {
            font-size: 20px;
            font-weight: 700;
            color: #E3836D;
        }
        
        .genre-card-artists-row {
            margin-bottom: 12px;
            margin-top: 12px;
        }
        
        .genre-card-artists-label {
            font-weight: 600;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            color: #999;
            margin-bottom: 6px;
        }
        
        .genre-card-artist-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        
        .genre-card-artist-tag {
            background: #f3f4f6;
            color: #212529;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 500;
            transition: all 0.2s;
            cursor: pointer;
        }
        
        .genre-card-artist-tag:hover {
            background: #E3836D;
            color: white;
        }
        
        .genre-card-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 12px;
            margin-top: 12px;
            border-top: 1px solid #f0f0f0;
            font-size: 11px;
        }
        
        .genre-card-added-by {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #666;
        }
        
        .genre-card-contributors-badges {
            display: flex;
            margin-left: -4px;
        }
        
        .genre-card-contributor-badge {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 10px;
            border: 2px solid white;
            margin-left: -4px;
            flex-shrink: 0;
        }
        
        .genre-card-contributor-badge:first-child {
            margin-left: 0;
        }
        
        .genre-card-contributors-text {
            font-size: 11px;
            color: #666;
        }
        
        .genre-card-percentage {
            font-size: 12px;
            color: #999;
            margin-top: 4px;
        }
        
        .albums-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(380px, 1fr));
            gap: 20px;
        }
        
        @media (max-width: 768px) {
            .albums-grid {
                grid-template-columns: 1fr;
                gap: 16px;
            }
        }
        
        @media (max-width: 480px) {
            .albums-grid {
                grid-template-columns: 1fr;
                gap: 12px;
                width: 100%;
                box-sizing: border-box;
            }
        }
        
        .album-card {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 16px;
            transition: all 0.2s;
            cursor: pointer;
            min-width: 0;
            width: 100%;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        
        @media (max-width: 480px) {
            .album-card {
                padding: 12px;
            }
        }
        
        .album-card:hover {
            box-shadow: 0 4px 12px var(--card-shadow);
            border-color: var(--accent-pop);
            transform: translateY(-2px);
        }
        
        .album-card-with-art {
            display: flex;
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .album-card-art {
            flex-shrink: 0;
            width: 85px;
            height: 85px;
            border-radius: 6px;
            overflow: hidden;
            background: #f3f4f6;
        }
        
        .album-card-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 0;
            width: 100%;
            flex-grow: 1;
        }
        
        .album-card-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 12px;
            margin-bottom: 12px;
            padding-bottom: 12px;
        }
        
        .album-card-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .album-card-name {
            font-size: 15px;
            font-weight: 700;
            color: var(--text-primary);
            line-height: 1.3;
        }
        
        .album-card-artist {
            font-size: 13px;
            color: var(--text-secondary);
            font-weight: 500;
            line-height: 1.2;
            margin-top: 4px;
        }
        
        .album-card-track-count {
            font-size: 12px;
            color: #999;
            font-style: italic;
            line-height: 1.2;
            margin-top: 4px;
        }
        
        .album-card-year-section {
            padding-left: 16px;
            border-left: 1px solid #f0f0f0;
            text-align: right;
        }
        
        .album-card-year-label {
            font-size: 10px;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .album-card-year-value {
            font-size: 16px;
            font-weight: 700;
            color: #E3836D;
        }
        
        .album-card-genres-row {
            margin-top: auto;
            margin-bottom: 0px;
            margin-left: -16px;
            margin-right: -16px;
            padding-left: 16px;
            padding-right: 16px;
            padding-top: 12px;
            padding-bottom: 12px;
            border-top: 1px solid #f0f0f0;
        }
        
        .album-card-genres-label {
            font-weight: 600;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            color: #999;
            margin-bottom: 6px;
        }
        
        .album-card-genre-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        
        .album-card-genre-tag {
            background: #f3f4f6;
            color: #212529;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 500;
            transition: all 0.2s;
            cursor: pointer;
        }
        
        .album-card-genre-tag:hover {
            background: #E3836D;
            color: white;
        }
        
        @media (max-width: 768px) {
            .album-card-art {
                width: 70px;
                height: 70px;
            }
        }
        
        @media (max-width: 480px) {
            .album-card-art {
                width: 70px;
                height: 70px;
            }
        }
        
        .album-card-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 12px;
            margin-top: 12px;
            border-top: 1px solid #f0f0f0;
            font-size: 11px;
        }
        
        .album-card-added-by {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #666;
        }
        
        .album-card-contributors-badges {
            display: flex;
            margin-left: -4px;
        }
        
        .album-card-contributor-badge {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 10px;
            border: 2px solid white;
            margin-left: -4px;
            flex-shrink: 0;
        }
        
        .album-card-contributor-badge:first-child {
            margin-left: 0;
        }
        
        .album-card-contributors-text {
            font-size: 11px;
            color: #666;
        }
        
        .album-card-release-date {
            font-size: 11px;
            color: #999;
        }
        
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-secondary);
        }
        .empty-state svg {
            width: 100px;
            height: 100px;
            margin-bottom: 20px;
            opacity: 0.3;
        }
        /* Contributors Card Layout */
.contributors-cards-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(380px, 1fr));
    gap: 20px;
    margin-bottom: 30px;
}

@media (max-width: 768px) {
    .contributors-cards-grid {
        grid-template-columns: 1fr;
        gap: 16px;
    }
}

.contributor-card {
    background: white;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 16px;
    transition: all 0.2s;
    cursor: pointer;
}

.contributor-card:hover {
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    border-color: #E3836D;
}

/* Add active state for mobile touch */
.contributor-card:active {
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    border-color: #E3836D;
}

/* Optional: Add a subtle scale effect on touch for better feedback */
@media (max-width: 768px) {
    .contributor-card:active {
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        border-color: #E3836D;
        transform: scale(0.98); /* Slight press-in effect */
    }
}
.contributor-card-top {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 12px; /* Reduced from 14px */
    padding-bottom: 12px; /* Reduced from 14px */
    border-bottom: 1px solid #f0f0f0;
}

.contributor-card-left {
    display: flex;
    align-items: center;
    gap: 12px;
    flex: 1;
}

.contributor-card-badge {
    width: 48px;
    height: 48px;
    border-radius: 50%;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    font-size: 14px;
    flex-shrink: 0;
}

.contributor-card-name-col {
    flex: 1;
    display: flex; /* Add this */
    flex-direction: column; /* Add this */
    gap: 4px; /* Add this - controls exact spacing between name and stats */
}

.contributor-card-name {
    font-size: 14px;
    font-weight: 700;
    color: #212529;
    margin-bottom: 0px; /* Changed from 2px to 0px */
    line-height: 1.2; /* Tighter line-height */
}

.contributor-card-tracks-pct {
    display: flex;
    gap: 16px;
    font-size: 12px;
    color: #666;
    line-height: 1; /* Tight line-height for stats */
    margin-top: 4px; /* Add small controlled spacing */
}

.contributor-card-right {
    text-align: right;
    padding-left: 16px;
    border-left: 1px solid #f0f0f0;
}

.contributor-card-active-label {
    font-size: 10px;
    color: #999;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 0px; /* Changed from 2px to 0px */
    line-height: 1.2; /* Tighter line-height */
}

.contributor-card-active-value {
    font-size: 16px;
    font-weight: 700;
    color: #E3836D;
    display: flex;
    align-items: center;
    justify-content: flex-end;
    gap: 4px;
    line-height: 1; /* Tight line-height for stats */
    margin-top: 4px; /* Add small controlled spacing */
}

.contributor-card-flame {
    width: 16px;
    height: 16px;
    color: #E3836D;
    fill: none;
    stroke: currentColor;
    stroke-width: 2;
    stroke-linecap: round;
    stroke-linejoin: round;
}

.contributor-card-info-grid {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 12px;
    margin-bottom: 12px;
    align-items: start; /* Prevents vertical stretching */
}

.contributor-card-column {
    display: flex;
    flex-direction: column;
    gap: 4px; /* Reduced from 8px */
}

.contributor-card-info-item {
    font-size: 12px;
    line-height: 1.3; /* Add explicit line-height */
}

.contributor-card-info-label {
    font-weight: 600;
    color: #999;
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.3px;
    margin-bottom: 2px; /* Add small margin */
    line-height: 1.2; /* Tighter line-height for labels */
}

.contributor-card-info-value {
    color: #212529;
    font-size: 12px;
    font-weight: 500;
    line-height: 1.4; /* Explicit line-height */
}

.contributor-card-footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding-top: 10px; /* Reduced from 12px */
    border-top: 1px solid #f0f0f0;
    font-size: 11px;
}

.contributor-card-rank {
    font-weight: 700;
    color: #E3836D;
    font-size: 12px;
}

.contributor-card-popularity {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 12px;
}

.contributor-card-popularity-label {
    color: #999;
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.3px;
}

.contributor-card-popularity-value {
    font-weight: 700;
    color: #E3836D;
    font-size: 13px;
}
/* Track Card Layout */
.tracks-cards-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 20px;
    margin-bottom: 30px;
    box-sizing: border-box;
    width: 100%;
}

@media (max-width: 900px) {
    .tracks-cards-grid {
        grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        gap: 16px;
    }
}

@media (max-width: 768px) {
    .tracks-cards-grid {
        grid-template-columns: 1fr;
        gap: 16px;
    }
}

@media (max-width: 480px) {
    .tracks-cards-grid {
        gap: 12px;
        grid-template-columns: 1fr;
        padding: 0 4px;
        box-sizing: border-box;
    }
}
.track-card {
    background: white;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 16px;
    transition: all 0.2s;
    cursor: pointer;
    max-width: 100%;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    height: 100%;
}

.track-card:hover {
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    border-color: #E3836D;
    transform: translateY(-2px);
}

@media (max-width: 480px) {
    .track-card {
        padding: 12px;
    }
}

.track-card:active {
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    border-color: #E3836D;
}

@media (max-width: 768px) {
    .track-card:active {
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        border-color: #E3836D;
        transform: scale(0.98);
    }
}

.track-card-top {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 12px;
    padding-bottom: 12px;
}

.track-card-info {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 4px;
    min-width: 0;
    overflow: hidden;
    flex-grow: 1;
}

.track-card-name {
    font-size: 15px;
    font-weight: 700;
    color: #212529;
    line-height: 1.3;
    margin-bottom: 0px;
    word-break: break-word;
    overflow-wrap: break-word;
}

.track-card-artist {
    font-size: 13px;
    color: #666;
    font-weight: 500;
    line-height: 1.2;
    margin-top: 4px;
    word-break: break-word;
    overflow-wrap: break-word;
}

.track-card-album {
    font-size: 12px;
    color: #999;
    font-style: italic;
    line-height: 1.2;
    margin-top: 4px;
}

.track-card-year-added {
    padding-left: 16px;
    border-left: 1px solid #f0f0f0;
    text-align: right;
    flex-shrink: 0;
    white-space: nowrap;
    margin-left: 8px;
}

.track-card-year-label {
    font-size: 10px;
    color: #999;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.track-card-year-value {
    font-size: 16px;
    font-weight: 700;
    color: #E3836D;
}

.track-card-genres-row {
    margin-top: auto;
    margin-bottom: 12px;
    padding-top: 12px;
    padding-bottom: 12px;
    border-top: 1px solid #f0f0f0;
    border-bottom: 1px solid #f0f0f0;
}

.track-card-genre-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    margin-top: 6px;
}

.track-card-genre-tag {
    background: #f3f4f6;
    color: #212529;
    padding: 4px 10px;
    border-radius: 12px;
    font-size: 11px;
    font-weight: 500;
    transition: all 0.2s;
}

.track-card-genre-tag:hover {
    background: #E3836D;
    color: white;
}

.track-card-footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding-top: 12px;
    font-size: 11px;
    flex-wrap: wrap;
    gap: 8px;
}

.track-card-added-by {
    display: flex;
    align-items: center;
    gap: 8px;
    color: #666;
    flex-shrink: 0;
}

.track-card-contributors-badges {
    display: flex;
    margin-left: -4px;
}

.track-card-contributor-badge {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    font-size: 10px;
    border: 2px solid white;
    margin-left: -4px;
    flex-shrink: 0;
}

.track-card-contributor-badge:first-child {
    margin-left: 0;
}

.track-card-contributors-text {
    font-size: 11px;
    color: #666;
}

.track-card-release-date {
    font-size: 11px;
    color: #999;
    min-width: 0;
    white-space: nowrap;
    flex: 0 1 auto;
}

.track-card-rank {
    font-weight: 700;
    color: #E3836D;
    font-size: 12px;
}

/* Touch active state for track cards */
.track-card.touch-active {
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    border-color: #E3836D;
    transform: scale(0.98);
}

/* Overlap Card Layout */
.overlap-card {
    background: white;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 16px;
    transition: all 0.2s;
    cursor: pointer;
}

.overlap-card:hover {
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    border-color: #E3836D;
    transform: translateY(-2px);
}

@media (max-width: 768px) {
    .overlap-card:active {
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        border-color: #E3836D;
        transform: scale(0.98);
    }
}

@media (max-width: 480px) {
    .overlap-card {
        padding: 12px;
    }
    
    #overlap-cards-container {
        gap: 12px !important;
    }
    
    .partnership-header-names {
        flex-direction: column !important;
        white-space: normal !important;
    }
    
    .partnership-header-names > div {
        display: block !important;
        white-space: normal !important;
        margin-bottom: 8px !important;
    }
    
    .partnership-header-names svg {
        display: block !important;
        margin: 8px auto !important;
    }
}

.overlap-badge {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    font-size: 13px;
    flex-shrink: 0;
    border: 2px solid white;
}
        .contributor-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            color: white;
        }
        /* Contributor display with name and badge */
.contributor-display {
    display: flex;
    align-items: center;
    gap: 12px;
}

.contributor-display .contributor-badge {
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    font-size: 12px;
}

.contributor-display .name {
    font-weight: 500;
    color: var(--text-primary);
}
        .filter-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }
        
       .filter-btn {
    padding: 10px 18px;
    border: none;
    background: #f3f4f6;
    color: #6b7280;
    border-radius: 8px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    transition: all 0.2s;
    min-width: 100px;
}

.filter-btn:hover {
    background: #e5e7eb;
    color: #374151;
}

.filter-btn.active {
    background: var(--accent-pop);
    color: white;
    border: none;
    font-weight: 600;
    min-width: 100px;
}

.filter-btn.active:hover {
    background: #c97456;
}

@media (max-width: 480px) {
    .filter-buttons {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
    }
    
    .filter-btn {
        padding: 12px 10px;
        font-size: 13px;
        min-width: 0;
        width: 100%;
    }
    
    .filter-btn.active {
        min-width: 0;
    }
}

#persistent-back-btn:hover {
    background: rgba(227, 131, 109, 1);
    box-shadow: 0 6px 16px rgba(0,0,0,0.2);
    transform: translateY(-2px);
}

</style>
    <style>
    /* Mobile-specific padding: bring content closer to edges on small screens */
    @media (max-width: 480px) {
        .header {
            padding: 18px 12px !important;
        }

        .content {
            padding: 16px 12px !important;
        }

        .tabs {
            padding-right: 12px !important;
            gap: 8px !important;
        }

        .tab {
            padding: 10px 12px !important;
            font-size: 15px !important;
        }

        /* Reduce card/grid paddings for very small screens */
        .grid {
            padding: 8px !important;
            gap: 10px !important;
        }
    }
    @media (min-width: 481px) and (max-width: 768px) {
        .header {
            padding: 20px 12px !important;
        }

        .content {
            padding: 20px 12px !important;
        }

        .tabs {
            padding-right: 12px !important;
            gap: 10px !important;
        }

        .tab {
            padding: 12px 14px !important;
            font-size: 15px !important;
        }
    }

    .track-card-with-art {
        display: flex;
        gap: 16px;
        align-items: flex-start;
        width: 100%;
    }

    .track-card-album-art {
        flex-shrink: 0;
        width: 85px;
        height: 85px;
        border-radius: 6px;
        overflow: hidden;
        background: #f3f4f6;
    }

    .track-card-album-art-placeholder {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
        color: #9ca3af;
        font-size: 12px;
    }

    .track-card-content {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 12px;
        width: 100%;
    }

    @media (max-width: 768px) {
        .track-card-with-art {
            gap: 12px;
        }

        .track-card-album-art {
            width: 70px;
            height: 70px;
        }
    }

    @media (max-width: 480px) {
        .track-card-with-art {
            gap: 12px;
        }

        .track-card-album-art {
            flex-shrink: 0;
            width: 70px;
            height: 70px;
        }
    }

    /* Artist Card Layout */
    .artists-cards-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
    }

    @media (max-width: 900px) {
        .artists-cards-grid {
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 16px;
        }
    }

    @media (max-width: 768px) {
        .artists-cards-grid {
            grid-template-columns: 1fr;
            gap: 16px;
        }
    }

    @media (max-width: 480px) {
        .artists-cards-grid {
            gap: 12px;
        }
    }

    .artist-card {
        background: white;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 20px;
        transition: all 0.2s;
        cursor: pointer;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        gap: 16px;
    }

    .artist-card:hover {
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        border-color: #E3836D;
        transform: translateY(-2px);
    }

    .artist-card:active {
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        border-color: #E3836D;
    }

    @media (max-width: 768px) {
        .artist-card:active {
            transform: scale(0.98);
        }
    }

    .artist-card-rank {
        font-size: 24px;
        font-weight: 700;
        color: #E3836D;
    }

    .artist-card-name {
        font-size: 16px;
        font-weight: 700;
        color: #212529;
        line-height: 1.3;
        word-break: break-word;
    }

    .artist-card-stats {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
    }

    .artist-card-stat {
        padding: 10px;
        background: #f3f4f6;
        border-radius: 6px;
        text-align: center;
    }

    .artist-card-stat-label {
        font-size: 11px;
        color: #999;
        text-transform: uppercase;
        font-weight: 600;
        letter-spacing: 0.3px;
        margin-bottom: 4px;
    }

    .artist-card-stat-value {
        font-size: 18px;
        font-weight: 700;
        color: #212529;
    }

    .artist-card-percentage {
        font-size: 14px;
        color: #E3836D;
        font-weight: 600;
    }

    /* New Artist Card Styles */
    .cards-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(380px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
        align-items: start;
    }

    @media (max-width: 900px) {
        .cards-grid {
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 16px;
        }
    }

    @media (max-width: 768px) {
        .cards-grid {
            grid-template-columns: 1fr;
            gap: 16px;
        }
    }

    .card {
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 16px;
        transition: all 0.2s;
        cursor: pointer;
        display: flex;
        flex-direction: column;
        gap: 0;
        height: 100%;
    }

    .card:hover {
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        border-color: #E3836D;
    }

    .card-top {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: 12px;
        padding-bottom: 0px;
        margin-top: 0px;
        margin: 0px;
        padding: 0px;
    }

    .card-info {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 0px;
        margin: 0px;
        padding: 0px;
        flex-grow: 1;
    }

    .card-artist-name {
        font-size: 17px;
        font-weight: 700;
        color: #212529;
        line-height: 1.3;
        margin-bottom: 0px;
        margin-top: 0px;
       }

    .card-track-count {
        font-size: 13px;
        color: #666;
        font-weight: 500;
        line-height: 1.2;
        margin-top: 4px;
    }

    .card-unique-count {
        font-size: 12px;
        color: #999;
        margin-top: 4px;
        margin-bottom: 12px;
    }

    .card-rank-section {
        padding-left: 16px;
        border-left: 1px solid #f0f0f0;
        text-align: right;
    }

    .card-rank-label {
        font-size: 10px;
        color: #999;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin-bottom: 4px;
    }

    .card-rank-value {
        font-size: 20px;
        font-weight: 700;
        color: #E3836D;
    }

    .card-albums-row {
        margin-bottom: 12px;
        padding-top: 12px;
        padding-bottom: 12px;
        border-top: 1px solid #f0f0f0;
        margin-top: auto;
    }

    .card-albums-label {
        font-weight: 600;
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.3px;
        color: #999;
        margin-bottom: 6px;
    }

    .card-album-tags {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
    }

    .card-album-tag {
        background: #f3f4f6;
        color: #212529;
        padding: 4px 10px;
        border-radius: 12px;
        font-size: 11px;
        font-weight: 500;
        transition: all 0.2s;
        cursor: pointer;
    }

    .card-album-tag:hover {
        background: #E3836D;
        color: white;
    }

    .card-footer {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding-top: 12px;
        margin-top: 12px;
        border-top: 1px solid #f0f0f0;
        font-size: 11px;
        flex-wrap: wrap;
        gap: 8px;
    }

    .card-added-by {
        display: flex;
        align-items: center;
        gap: 8px;
        color: #666;
    }

    .card-contributors-badges {
        display: flex;
        margin-left: -4px;
    }

    .contributor-badge {
        width: 24px;
        height: 24px;
        border-radius: 50%;
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 700;
        font-size: 10px;
        border: 2px solid white;
        margin-left: -4px;
        flex-shrink: 0;
    }

    .contributor-badge:first-child {
        margin-left: 0;
    }

    .card-contributors-text {
        font-size: 11px;
        color: #666;
    }

    .card-years-active {
        font-size: 11px;
        color: #999;
        min-width: 0;
        white-space: nowrap;
        flex: 0 1 auto;
    }

    .toggle-switch-container {
        position: relative;
        display: inline-block;
        width: 50px;
        height: 26px;
    }

    .toggle-switch-input {
        opacity: 0;
        width: 0;
        height: 0;
    }

    .toggle-switch-slider {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        transition: 0.3s;
        border-radius: 26px;
        cursor: pointer;
    }

    .toggle-switch-slider:before {
        content: '';
        position: absolute;
        height: 20px;
        width: 20px;
        left: 3px;
        bottom: 3px;
        background-color: white;
        transition: 0.3s;
        border-radius: 50%;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .toggle-switch-input:checked + .toggle-switch-slider {
        background-color: #E3836D;
    }

    .toggle-switch-input:checked + .toggle-switch-slider:before {
        transform: translateX(24px);
    }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
<div style="display: flex; align-items: center; width: 100%; gap: 10px; flex-wrap: wrap;">
            <div style="width: 40px; height: 40px; background: #DE846C; border-radius: 8px; display: flex; align-items: center; justify-content: center; flex-shrink: 0; margin-top: 4px;">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M9 18V5l12-2v13"></path>
            <circle cx="6" cy="18" r="3"></circle>
            <circle cx="18" cy="16" r="3"></circle>
        </svg>
    </div>
    <div style="flex: 1;">
        <h1 style="margin: 0; line-height: 1.2;">Music Week Archive</h1>
        <p style="margin: 4px 0 0 0; font-size: 14px; color: #757575;">2018 – 2024</p>
    </div>
</div>
        
        <div class="content">
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p style="color: #E3836D; font-size: 18px; font-weight: 600;">Analyzing your music library...</p>
            </div>

            <div id="results" style="display: none;">
            <!-- Mobile menu button -->
    <div class="mobile-menu-wrap">
        <button class="mobile-menu-btn" style="display: none;" onclick="toggleMobileMenu(event)" title="Menu" aria-expanded="false">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                <path d="M4 7h16" />
                <path d="M4 12h16" />
                <path d="M4 17h16" />
            </svg>
            <span class="mobile-menu-btn-text">Menu</span>
        </button>
    </div>

    <!-- Dropdown menu (hidden by default) -->
    <div class="dropdown-menu hidden" id="mobileDropdown">
        <button onclick="switchTabMobile('overview', event)">
    <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <polyline points="23 6 13.5 15.5 8.5 10.5 1 18"></polyline>
        <polyline points="17 6 23 6 23 12"></polyline>
    </svg>
            Overview
        </button>
        <button onclick="switchTabMobile('albums', event)">
            <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10"></circle>
                <circle cx="12" cy="12" r="3"></circle>
            </svg>
            Albums
        </button>
        <button onclick="switchTabMobile('artists', event)">
            <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                <circle cx="12" cy="7" r="4"></circle>
            </svg>
            Artists
        </button>
        <button onclick="switchTabMobile('contributors', event)">
            <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                <circle cx="9" cy="7" r="4"></circle>
                <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
            </svg>
            Contributors
        </button>
        <button onclick="switchTabMobile('genres', event)">
<svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M4 9v6M8 3v12M12 6v9M16 9v6M20 5v14"></path>
    </svg>
            Genres
        </button>
        <button onclick="switchTabMobile('partners', event)">
            <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="m11 17 2 2a1 1 0 1 0 3-3"></path>
                <path d="m14 14 2.5 2.5a1 1 0 1 0 3-3l-3.88-3.88a3 3 0 0 0-4.24 0l-.88.88a1 1 0 1 1-3-3l2.81-2.81a5.79 5.79 0 0 1 7.06-.87l.47.28a2 2 0 0 0 1.42.25L21 4"></path>
                <path d="m21 3 1 11h-2"></path>
                <path d="M3 3 2 14l6.5 6.5a1 1 0 1 0 3-3"></path>
                <path d="M3 4h8"></path>
            </svg>
            Partners
        </button>
        <button onclick="switchTabMobile('playlists', event)">
    <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M8 6h13M8 12h13M8 18h13M3 6h.01M3 12h.01M3 18h.01"></path>
    </svg>
            Playlists
        </button>
        <button onclick="switchTabMobile('tracks', event)">
            <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M9 18V5l12-2v13"></path>
                <circle cx="6" cy="18" r="3"></circle>
                <circle cx="18" cy="16" r="3"></circle>
            </svg>
            Tracks
        </button>
    </div>    
<div style="display: flex; align-items: center; width: 100%; position: relative; gap: 20px;">
    <!-- Desktop tabs -->
    <div class="tabs">
        <button class="tab active" onclick="switchTab('overview')">
    <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <polyline points="23 6 13.5 15.5 8.5 10.5 1 18"></polyline>
        <polyline points="17 6 23 6 23 12"></polyline>
    </svg>
            <span>Overview</span>
        </button>
        <button class="tab" onclick="switchTab('albums')">
            <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10"></circle>
                <circle cx="12" cy="12" r="3"></circle>
            </svg>Albums
        </button>
        <button class="tab" onclick="switchTab('artists')">
            <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                <circle cx="12" cy="7" r="4"></circle>
            </svg>Artists
        </button>
        <button class="tab" onclick="switchTab('contributors')">
            <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                <circle cx="9" cy="7" r="4"></circle>
                <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
            </svg>Contributors
        </button>
        <button class="tab" onclick="switchTab('genres')">
<svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M4 9v6M8 3v12M12 6v9M16 9v6M20 5v14"></path>
    </svg>Genres
        </button>
        <button class="tab" onclick="switchTab('partners')">
            <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="m11 17 2 2a1 1 0 1 0 3-3"></path>
                <path d="m14 14 2.5 2.5a1 1 0 1 0 3-3l-3.88-3.88a3 3 0 0 0-4.24 0l-.88.88a1 1 0 1 1-3-3l2.81-2.81a5.79 5.79 0 0 1 7.06-.87l.47.28a2 2 0 0 0 1.42.25L21 4"></path>
                <path d="m21 3 1 11h-2"></path>
                <path d="M3 3 2 14l6.5 6.5a1 1 0 1 0 3-3"></path>
                <path d="M3 4h8"></path>
            </svg>Partners
        </button>
        <button class="tab" onclick="switchTab('playlists')">
    <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M8 6h13M8 12h13M8 18h13M3 6h.01M3 12h.01M3 18h.01"></path>
    </svg>
    Playlists
        </button>
        <button class="tab" onclick="switchTab('tracks')">
            <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M9 18V5l12-2v13"></path>
                <circle cx="6" cy="18" r="3"></circle>
                <circle cx="18" cy="16" r="3"></circle>
            </svg>Tracks
        </button>
    </div>

    
</div>

                <div id="overview" class="tab-content active"></div>
                <div id="artists" class="tab-content"></div>
                <div id="tracks" class="tab-content"></div>
                <div id="albums" class="tab-content"></div>
                <div id="genres" class="tab-content"></div>
                <div id="contributors" class="tab-content"></div>
                <div id="partners" class="tab-content"></div>
                <div id="playlists" class="tab-content"></div>
            </div>
        </div>
    </div>

    <!-- Persistent Back Button -->
    <button id="persistent-back-btn" onclick="goBack()" style="position: fixed; bottom: 20px; right: 20px; background: rgba(227, 131, 109, 0.85); color: white; border: none; padding: 12px 20px; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 600; display: none; align-items: center; gap: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); transition: all 0.2s; z-index: 1000;">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="19" y1="12" x2="5" y2="12"></line>
            <polyline points="12 19 5 12 12 5"></polyline>
        </svg>
        Back
    </button>

    <script>
        let globalData = {};
        let contributorColors = {};

        // Lazy load images as they become visible
        let missingArtworkImages = [];
        
        function setupLazyLoading() {
            const imageObserver = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const img = entry.target;
                        if (img.dataset.src) {
                            // Add error logging
                            img.onerror = function() {
                                const primaryUrl = this.dataset.src;
                                const fallbackUrl = this.dataset.srcFallback;
                                const albumName = this.alt || 'Unknown';
                                
                                if (!this.dataset.tried) {
                                    this.dataset.tried = '1';
                                    this.src = this.dataset.srcFallback || '';
                                } else {
                                    // Both primary and fallback failed
                                    this.style.display = 'none';
                                    if (this.parentElement) {
                                        this.parentElement.innerHTML += '<div class="track-card-album-art-placeholder"></div>';
                                        // Log missing artwork for debugging
                                        missingArtworkImages.push({
                                            album: albumName,
                                            primaryUrl: primaryUrl,
                                            fallbackUrl: fallbackUrl,
                                            timestamp: new Date().toISOString()
                                        });
                                    }
                                }
                            };
                            img.src = img.dataset.src;
                            img.removeAttribute('data-src');
                            observer.unobserve(img);
                        }
                    }
                });
            }, {
                rootMargin: '50px' // Start loading 50px before the image enters viewport
            });

            // Observe all album art images
            document.querySelectorAll('[data-lazy-load="album-art"]').forEach(img => {
                imageObserver.observe(img);
            });
        }

        // Re-run lazy loading when DOM content changes
        function reinitializeLazyLoading() {
            setupLazyLoading();
        }

function loadCSVFromGitHub() {
    const csvUrl = "https://cdn.jsdelivr.net/gh/mcmillon/music-week-archive@main/Full%20Archive-test-mod2%2Bplaylists.csv";

    document.getElementById("loading").style.display = "block";
    document.getElementById("results").style.display = "none";
    
    console.log("Starting CSV load from:", csvUrl);

    fetch(csvUrl)
        .then(response => {
            console.log("Fetch response status:", response.status);
            if (!response.ok) throw new Error("HTTP error " + response.status);
            return response.text();
        })
        .then(csvText => {
            console.log("CSV text received, length:", csvText.length);
            Papa.parse(csvText, {
                header: true,
                skipEmptyLines: true,
                dynamicTyping: false,
                complete: function (results) {
                    console.log("CSV parsed, rows:", results.data.length);
                    try {
                        analyzeData(results.data);
                        console.log("Data analysis complete");
                        document.getElementById("loading").style.display = "none";
                        document.getElementById("results").style.display = "block";
                    } catch (e) {
                        console.error("Error in analyzeData:", e);
                        alert("Error processing data: " + e.message);
                        document.getElementById("loading").style.display = "none";
                    }
                },
                error: function (error) {
                    console.error("CSV Parse error:", error);
                    alert("Error parsing CSV: " + error.message);
                    document.getElementById("loading").style.display = "none";
                }
            });
        })
        .catch(err => {
            console.error("Fetch error:", err);
            alert("Error loading CSV from GitHub:\n" + err.message);
            document.getElementById("loading").style.display = "none";
        });
}
        
function getContributorColor(contributor) {
    if (!contributorColors[contributor]) {
        const colors = [
            '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8',
            '#F7DC6F', '#BB8FCE', '#85C1E2', '#FF6B9D', '#C44569',
            '#A8E6CF', '#FFD3B6', '#FFAAA5', '#FF8B94', '#A8D8EA'
        ];
        const index = Object.keys(contributorColors).length % colors.length;
        contributorColors[contributor] = colors[index];
    }
    return contributorColors[contributor];
}
        
        function formatContributorBadge(contributor) {
            const color = getContributorColor(contributor);
            return `<span class="contributor-badge" style="background: ${color};">${contributor}</span>`;
        }

        function formatContributorWithName(contributor) {
    const color = getContributorColor(contributor);
    // Extract initials from "firstName.lastName" format
    const parts = contributor.split('.');
    const initials = (parts[0][0] + (parts[1]?.[0] || '')).toUpperCase();
    
    // Format full name: "anna.hoffman" -> "Anna Hoffman"
    let firstName = parts[0] ? parts[0].charAt(0).toUpperCase() + parts[0].slice(1) : '';
    let lastName = parts[1] ? parts[1].charAt(0).toUpperCase() + parts[1].slice(1) : '';
    
    // Hard code special case for trey.mcmillon -> Trey McMillon
if (contributor === 'trey.mcmillon') {
    firstName = 'Trey';
    lastName = 'McMillon';
}
    
    const fullName = lastName ? `${firstName} ${lastName}` : firstName;
    
    return `
        <div class="contributor-display">
            <span class="name">${fullName}</span>
            <span class="contributor-badge" style="background: ${color};" title="${contributor}">
                ${initials}
            </span>
        </div>
    `;
}

function getFormattedContributorName(contributor) {
    const parts = contributor.split('.');
    let firstName = parts[0] ? parts[0].charAt(0).toUpperCase() + parts[0].slice(1) : '';
    let lastName = parts[1] ? parts[1].charAt(0).toUpperCase() + parts[1].slice(1) : '';
    
    // Hard code special case for trey.mcmillon -> Trey McMillon
    if (contributor === 'trey.mcmillon') {
        firstName = 'Trey';
        lastName = 'McMillon';
    }
    
    return lastName ? `${firstName} ${lastName}` : firstName;
}

// Scroll position management
const scrollPositions = {};

function saveScrollPosition(key) {
    scrollPositions[key] = window.scrollY;
}

function restoreScrollPosition(key) {
    if (scrollPositions[key] !== undefined) {
        // Use longer delay to ensure DOM rendering is complete
        setTimeout(() => {
            window.scrollTo(0, scrollPositions[key]);
        }, 100);
    }
}

// Back navigation handlers for each tab - render then restore scroll position
function backToArtists() {
    renderArtists();
    const savedPos = scrollPositions['artists'];
    if (savedPos !== undefined) {
        setTimeout(() => window.scrollTo(0, savedPos), 150);
    }
}

function backToAlbums() {
    renderAlbums();
    const savedPos = scrollPositions['albums'];
    if (savedPos !== undefined) {
        setTimeout(() => window.scrollTo(0, savedPos), 150);
    }
}

function backToGenres() {
    renderGenres();
    const savedPos = scrollPositions['genres'];
    if (savedPos !== undefined) {
        setTimeout(() => window.scrollTo(0, savedPos), 150);
    }
}

function backToPartners() {
    renderPartners();
    const savedPos = scrollPositions['partners'];
    if (savedPos !== undefined) {
        setTimeout(() => window.scrollTo(0, savedPos), 150);
    }
}

// Format display name for tight spaces - use first name only if full name is too long
function getCompactDisplayName(firstName, lastName) {
    const fullName = lastName ? `${firstName} ${lastName}` : firstName;
    // If the full name is longer than 9 characters, just use first name
    if (fullName.length > 9) {
        return firstName;
    }
    return fullName;
}

function filterContributorCards(searchTerm) {
    const cards = document.querySelectorAll('.contributor-card');
    const filter = searchTerm.toLowerCase();
    
    cards.forEach(card => {
        const name = card.getAttribute('data-name').toLowerCase();
        const displayName = card.querySelector('.contributor-card-name').textContent.toLowerCase();
        
        if (name.includes(filter) || displayName.includes(filter)) {
            card.style.display = '';
        } else {
            card.style.display = 'none';
        }
    });
}

function filterTrackCards(searchTerm) {
    const cards = document.querySelectorAll('.track-card');
    const filter = searchTerm.toLowerCase();
    
    cards.forEach(card => {
        const name = card.getAttribute('data-name');
        const artist = card.getAttribute('data-artist');
        
        if (name.includes(filter) || artist.includes(filter)) {
            card.style.display = '';
        } else {
            card.style.display = 'none';
        }
    });
}

function filterArtistCards(searchTerm) {
    const cards = document.querySelectorAll('#artists-cards .card');
    const filter = searchTerm.toLowerCase();
    
    cards.forEach(card => {
        const name = card.getAttribute('data-name');
        
        if (name.includes(filter)) {
            card.style.display = '';
        } else {
            card.style.display = 'none';
        }
    });
}

function filterAlbumCards(searchTerm) {
    const cards = document.querySelectorAll('.card');
    const filter = searchTerm.toLowerCase();
    
    cards.forEach(card => {
        const name = card.getAttribute('data-name') || '';
        
        if (name.includes(filter)) {
            card.style.display = '';
        } else {
            card.style.display = 'none';
        }
    });
}

function switchTab(tabName) {
            // Save scroll position for current tab before switching
            const currentActive = document.querySelector('.tab-content.active');
            if (currentActive) {
                const currentTabName = currentActive.id;
                if (currentTabName) {
                    saveScrollPosition(currentTabName);
                }
            }
            
            // Track navigation history
            if (!window.navigationHistory) {
                window.navigationHistory = [];
            }
            if (window.navigationHistory.length === 0 || window.navigationHistory[window.navigationHistory.length - 1] !== tabName) {
                window.navigationHistory.push(tabName);
            }
            
            // If switching to genres tab from menu, reset to main genres view
            if (tabName === 'genres') {
                renderGenres();
            }
            
            // If switching to partners tab, render partners
            if (tabName === 'partners') {
                renderPartners();
            }
            
            // Update back button visibility
            const backBtn = document.getElementById('persistent-back-btn');
            if (backBtn) {
                backBtn.style.display = window.navigationHistory.length > 1 ? 'flex' : 'none';
            }
            
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            if (event && event.target) {
                event.target.classList.add('active');
            } else {
                // Manually find and set active tab if no event
                const tabButtons = document.querySelectorAll('.tab');
                tabButtons.forEach(tab => {
                    if (tab.onclick && tab.onclick.toString().includes(tabName)) {
                        tab.classList.add('active');
                    }
                });
            }
            document.getElementById(tabName).classList.add('active');
        }
        
        function goBack() {
            if (!window.navigationHistory) return;
            
            // Get the current tab before removing it
            const currentTab = window.navigationHistory[window.navigationHistory.length - 1];
            
            // Remove current tab from history
            window.navigationHistory.pop();
            
            if (window.navigationHistory.length > 0) {
                const previousTab = window.navigationHistory[window.navigationHistory.length - 1];
                const savedScrollPos = scrollPositions[previousTab];
                
                const tabButton = Array.from(document.querySelectorAll('.tab')).find(tab => 
                    tab.onclick && tab.onclick.toString().includes(previousTab)
                );
                if (tabButton) {
                    tabButton.click();
                    
                    // Restore scroll position after rendering completes
                    setTimeout(() => {
                        if (savedScrollPos !== undefined) {
                            window.scrollTo(0, savedScrollPos);
                        }
                    }, 100);
                }
            }
            
            // Update back button visibility
            const backBtn = document.getElementById('persistent-back-btn');
            if (backBtn) {
                backBtn.style.display = window.navigationHistory.length > 1 ? 'flex' : 'none';
            }
        }

        function normalize(str) {
            return str ? String(str).trim().replace(/\s+/g, ' ') : '';
        }

        function countFrequency(data, field, splitDelimiters = false) {
            const counts = {};
            
            data.forEach(row => {
                let values = [row[field]];
                
                if (splitDelimiters && row[field]) {
                    const fieldValue = String(row[field]);
                    values = fieldValue.split(/[;,]/).map(v => v.trim());
                    
                    const expandedValues = [];
                    values.forEach(val => {
                        if (val.includes(' & ')) {
                            expandedValues.push(...val.split(' & ').map(v => v.trim()));
                        } else {
                            expandedValues.push(val);
                        }
                    });
                    values = expandedValues;
                }
                
                values.forEach(value => {
                    if (!value) return;
                    const normalized = normalize(value);
                    counts[normalized] = (counts[normalized] || 0) + 1;
                });
            });
            return Object.entries(counts).sort((a, b) => b[1] - a[1]);
        }

        function parseDuration(duration) {
            if (!duration) return 0;
            
            const numValue = Number(duration);
            
            if (!isNaN(numValue)) {
                if (numValue > 1000) {
                    return Math.floor(numValue / 1000);
                }
                return Math.floor(numValue);
            }
            
            const strValue = String(duration);
            if (strValue.includes(':')) {
                const parts = strValue.split(':').map(Number);
                if (parts.length === 2) return parts[0] * 60 + parts[1];
                if (parts.length === 3) return parts[0] * 3600 + parts[1] * 60 + parts[2];
            }
            
            return 0;
        }

        function formatDuration(seconds) {
            if (seconds < 60) {
                return `${seconds}s`;
            }
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            if (hours > 0) return `${hours}h ${minutes}m ${secs}s`;
            return `${minutes}m ${secs}s`;
        }

        // Debug function to show missing artwork
        function showMissingArtwork() {
            if (missingArtworkImages.length === 0) {
                console.log('✅ All artwork loaded successfully!');
                alert('✅ All artwork loaded successfully!');
            } else {
                const summary = `Missing Artwork Report:\n\nTotal missing: ${missingArtworkImages.length}\n\nSample (first 20):`;
                console.table(missingArtworkImages.slice(0, 20));
                
                // Show in alert with first few
                const samples = missingArtworkImages.slice(0, 5).map(img => `• ${img.album}`).join('\n');
                alert(`Missing Artwork: ${missingArtworkImages.length} items\n\nSamples:\n${samples}...`);
            }
        }

        function analyzeData(data) {
            // Initialize contributor analysis objects
            const contributorYears = {};
            const contributorTopArtists = {};
            const contributorTopGenres = {};
            const contributorPopularity = {};
            const years = {};
            const addedYears = {};
            
            // Process data for contributor stats
            data.forEach(row => {
                const contributor = normalize(row['Added By']);
                const addedAt = row['Added At'];
                const artist = row['Artist Name(s)'];
                const genre = row['Genre'];
                const popularity = row['Popularity'] || row['popularity'];
                
                if (contributor) {
                    // Track years
                    if (addedAt) {
                                const year = extractYearFromAddedAt(addedAt);
                        if (year && year !== 'N/A') {
                            if (!contributorYears[contributor]) contributorYears[contributor] = {};
                            contributorYears[contributor][year] = true;
                        }
                    }
                    
                    // Track artists
                    if (artist) {
                        if (!contributorTopArtists[contributor]) contributorTopArtists[contributor] = {};
                        const artists = String(artist).split(/[;,&]/).map(a => normalize(a.trim()));
                        artists.forEach(a => {
                            if (a) contributorTopArtists[contributor][a] = (contributorTopArtists[contributor][a] || 0) + 1;
                        });
                    }
                    
                    // Track genres
                    if (genre) {
                        if (!contributorTopGenres[contributor]) contributorTopGenres[contributor] = {};
                        const genres = String(genre).split(/[;,]/).map(g => normalize(g.trim()));
                        genres.forEach(g => {
                            if (g) contributorTopGenres[contributor][g] = (contributorTopGenres[contributor][g] || 0) + 1;
                        });
                    }
                    
                    // Track popularity
                    if (popularity && !isNaN(popularity)) {
                        if (!contributorPopularity[contributor]) {
                            contributorPopularity[contributor] = { total: 0, count: 0 };
                        }
                        contributorPopularity[contributor].total += Number(popularity);
                        contributorPopularity[contributor].count += 1;
                    }
                }
                
                // Track release years
                const releaseDate = row['Release Date'];
                if (releaseDate) {
                    const year = extractYearFromAddedAt(releaseDate);
                    if (year && year !== 'N/A') {
                        years[year] = (years[year] || 0) + 1;
                    }
                }
                
                // Track added years
                if (addedAt) {
                    const year = extractYearFromAddedAt(addedAt);
                    if (year && year !== 'N/A') {
                        addedYears[year] = (addedYears[year] || 0) + 1;
                    }
                }
            });
            
            // Build lookup maps for fast O(1) access during rendering
            const trackGenresMap = {};
            const trackReleaseMap = {};
            const trackDataMap = {};
            const trackContributorsMap = {};
            const albumTracksMap = {};
            const artistTracksMap = {};
            const genreTracksMap = {};
            const artistDataMap = {};
            const artistYears = {};
            const artistYearCounts = {};
            const albumDataMap = {};
            const genreDataMap = {};
            const playlistDataMap = {};
            
            data.forEach(row => {
                const trackId = row['Track ID'];
                const albumName = row['Album Name'];
                const artistNames = row['Artist Name(s)'];
                const genreNames = row['Genre'];
                const addedAt = row['Added At'] || '';
                const releaseDate = row['Release Date'] || '';
                
                if (trackId) {
                    // Store genres by Track ID
                    if (row['Genre'] && !trackGenresMap[trackId]) {
                        const genres = String(row['Genre']).split(/[;,]/).map(g => g.trim()).filter(g => g);
                        trackGenresMap[trackId] = genres;
                    }
                    // Store release date by Track ID (use first occurrence)
                    if (row['Release Date'] && !trackReleaseMap[trackId]) {
                        trackReleaseMap[trackId] = row['Release Date'];
                    }
                    // Store full track data by Track ID (use first occurrence)
                    if (!trackDataMap[trackId]) {
                        trackDataMap[trackId] = row;
                    }
                    // Store contributors by Track ID
                    if (!trackContributorsMap[trackId]) {
                        trackContributorsMap[trackId] = [];
                    }
                    const contributor = row['Added By'];
                    if (contributor && !trackContributorsMap[trackId].includes(contributor)) {
                        trackContributorsMap[trackId].push(contributor);
                    }
                }
                
                // Build artist data map for faster renderArtists
                if (artistNames) {
                    const artists = String(artistNames).split(/[;,&]/).map(a => a.trim()).filter(a => a);
                    const albumName = row['Album Name'] || '';
                    const addedBy = row['Added By'] || '';
                    
                    artists.forEach(artist => {
                        if (!artistDataMap[artist]) {
                            artistDataMap[artist] = {
                                albums: {},
                                contributors: {},
                                uniqueTrackIds: new Set(),
                                minYear: Infinity,
                                maxYear: 0,
                                peakYear: null,
                                peakYearCount: 0
                            };
                        }
                        
                        // Track unique tracks
                        if (trackId) {
                            artistDataMap[artist].uniqueTrackIds.add(trackId);
                        }
                        
                        // Track albums
                        if (albumName) {
                            artistDataMap[artist].albums[albumName] = (artistDataMap[artist].albums[albumName] || 0) + 1;
                        }
                        
                        // Track contributors
                        if (addedBy) {
                            artistDataMap[artist].contributors[addedBy] = (artistDataMap[artist].contributors[addedBy] || 0) + 1;
                        }
                        
                        // Track years
                        const year = parseInt(addedAt.split('-')[0]) || parseInt(releaseDate);
                        if (year && !isNaN(year)) {
                            artistDataMap[artist].minYear = Math.min(artistDataMap[artist].minYear, year);
                            artistDataMap[artist].maxYear = Math.max(artistDataMap[artist].maxYear, year);
                            artistYears[year] = true;
                            
                            // Count adds per year for this artist
                            if (!artistYearCounts[artist]) {
                                artistYearCounts[artist] = {};
                            }
                            artistYearCounts[artist][year] = (artistYearCounts[artist][year] || 0) + 1;
                            
                            // Track peak year for this artist
                            if (artistYearCounts[artist][year] > artistDataMap[artist].peakYearCount) {
                                artistDataMap[artist].peakYearCount = artistYearCounts[artist][year];
                                artistDataMap[artist].peakYear = year;
                            }
                        }
                    });
                }
                
                // Index tracks by album
                if (albumName) {
                    const normalizedAlbum = normalize(albumName);
                    if (!albumTracksMap[normalizedAlbum]) {
                        albumTracksMap[normalizedAlbum] = [];
                    }
                    if (trackId && !albumTracksMap[normalizedAlbum].find(t => t['Track ID'] === trackId)) {
                        albumTracksMap[normalizedAlbum].push(row);
                    }
                }
                
                // Index tracks by artist
                if (artistNames) {
                    const artists = String(artistNames).split(/[;,&]/).map(a => a.trim());
                    artists.forEach(artist => {
                        const normalizedArtist = normalize(artist);
                        if (!artistTracksMap[normalizedArtist]) {
                            artistTracksMap[normalizedArtist] = [];
                        }
                        if (trackId && !artistTracksMap[normalizedArtist].find(t => t['Track ID'] === trackId)) {
                            artistTracksMap[normalizedArtist].push(row);
                        }
                    });
                }
                
                // Index tracks by genre
                if (genreNames) {
                    const genres = String(genreNames).split(/[;,]/).map(g => g.trim());
                    const expandedGenres = [];
                    genres.forEach(val => {
                        if (val.includes(' & ')) {
                            expandedGenres.push(...val.split(' & ').map(v => v.trim()));
                        } else {
                            expandedGenres.push(val);
                        }
                    });
                    expandedGenres.forEach(genre => {
                        const normalizedGenre = normalize(genre);
                        if (!genreTracksMap[normalizedGenre]) {
                            genreTracksMap[normalizedGenre] = [];
                        }
                        if (trackId && !genreTracksMap[normalizedGenre].find(t => t['Track ID'] === trackId)) {
                            genreTracksMap[normalizedGenre].push(row);
                        }
                    });
                }
                
                // Build album data map for faster renderAlbums
                if (albumName) {
                    const normalizedAlbum = normalize(albumName);
                    if (!albumDataMap[normalizedAlbum]) {
                        albumDataMap[normalizedAlbum] = {
                            displayName: albumName,
                            artists: {},
                            genres: {},
                            contributors: {},
                            trackIds: new Set(),
                            year: 'N/A'
                        };
                    }
                    
                    // Track primary artist (first artist listed)
                    if (artistNames) {
                        const firstArtist = String(artistNames).split(/[;,&]/)[0].trim();
                        albumDataMap[normalizedAlbum].artists[firstArtist] = true;
                    }
                    
                    // Track genres
                    if (genreNames) {
                        const genres = String(genreNames).split(/[;,]/).map(g => g.trim()).filter(g => g);
                        genres.forEach(genre => {
                            albumDataMap[normalizedAlbum].genres[genre] = (albumDataMap[normalizedAlbum].genres[genre] || 0) + 1;
                        });
                    }
                    
                    // Track contributors
                    if (row['Added By']) {
                        albumDataMap[normalizedAlbum].contributors[row['Added By']] = (albumDataMap[normalizedAlbum].contributors[row['Added By']] || 0) + 1;
                    }
                    
                    // Track unique track IDs
                    if (trackId) {
                        albumDataMap[normalizedAlbum].trackIds.add(trackId);
                    }
                    
                    // Track year (use first/most recent)
                    if (albumDataMap[normalizedAlbum].year === 'N/A' && addedAt) {
                        const year = extractYearFromAddedAt(addedAt);
                        if (year && year !== 'N/A') {
                            albumDataMap[normalizedAlbum].year = year;
                        }
                    }
                }
                
                // Build genre data map for faster renderGenres
                if (genreNames) {
                    const genres = String(genreNames).split(/[;,]/).map(g => g.trim()).filter(g => g);
                    genres.forEach(genre => {
                        if (!genreDataMap[genre]) {
                            genreDataMap[genre] = {
                                artists: {},
                                contributors: {},
                                trackCount: 0
                            };
                        }
                        
                        genreDataMap[genre].trackCount++;
                        
                        if (artistNames) {
                            const artists = String(artistNames).split(/[;,&]/).map(a => a.trim()).filter(a => a);
                            artists.forEach(artist => {
                                genreDataMap[genre].artists[artist] = (genreDataMap[genre].artists[artist] || 0) + 1;
                            });
                        }
                        
                        if (row['Added By']) {
                            genreDataMap[genre].contributors[row['Added By']] = (genreDataMap[genre].contributors[row['Added By']] || 0) + 1;
                        }
                    });
                }
                
                // Build playlist data map for faster renderPlaylists
                const playlistName = row['Playlist Name'];
                const playlistURI = row['Playlist URI'];
                if (playlistURI && playlistName) {
                    if (!playlistDataMap[playlistURI]) {
                        playlistDataMap[playlistURI] = {
                            name: playlistName,
                            uri: playlistURI,
                            contributors: new Set(),
                            years: new Set(),
                            trackCount: 0
                        };
                    }
                    
                    playlistDataMap[playlistURI].trackCount++;
                    
                    const contributor = normalize(row['Added By']);
                    if (contributor) {
                        playlistDataMap[playlistURI].contributors.add(contributor);
                    }
                    
                    if (addedAt) {
                        const year = extractYearFromAddedAt(addedAt);
                        if (year && year !== 'N/A') {
                            playlistDataMap[playlistURI].years.add(year);
                        }
                    }
                }
            });
            
            // Pre-compute consolidated genre tracks (deduplicated by track ID) for faster showGenreDetails
            const genreConsolidatedTracksMap = {};
            Object.keys(genreTracksMap).forEach(normalizedGenre => {
                const genreTracksRaw = genreTracksMap[normalizedGenre];
                const trackDataMap = {};
                const seen = {};
                
                // Collect all rows for each track to get contributor count and most recent date
                for (let i = 0; i < genreTracksRaw.length; i++) {
                    const row = genreTracksRaw[i];
                    const trackId = row['Track ID'];
                    if (trackId) {
                        if (!trackDataMap[trackId]) {
                            trackDataMap[trackId] = {
                                name: row['Track Name'],
                                artist: row['Artist Name(s)'],
                                year: extractYearFromAddedAt(row['Added At']) || 'N/A',
                                contributors: new Set(),
                                dates: []
                            };
                        }
                        const contributor = row['Added By'];
                        if (contributor) trackDataMap[trackId].contributors.add(contributor);
                        if (row['Added At']) trackDataMap[trackId].dates.push(new Date(row['Added At']));
                    }
                }
                
                // Convert to array and sort
                const consolidatedArray = Object.entries(trackDataMap).map(([trackId, data]) => {
                    const mostRecentDate = data.dates.length > 0 ? new Date(Math.max(...data.dates.map(d => d.getTime()))) : new Date(0);
                    return [
                        data.name,
                        data.artist,
                        trackId,
                        data.year,
                        data.contributors.size,
                        mostRecentDate
                    ];
                }).sort((a, b) => {
                    // Primary sort: by contributor count (descending)
                    if (b[4] !== a[4]) return b[4] - a[4];
                    // Secondary sort: by most recent date (descending)
                    return b[5] - a[5];
                });
                
                genreConsolidatedTracksMap[normalizedGenre] = consolidatedArray;
            });
            
            // Pre-compute consolidated artist tracks (deduplicated by track ID) for faster showArtistDetails
            const artistConsolidatedTracksMap = {};
            Object.keys(artistTracksMap).forEach(normalizedArtist => {
                const artistTracksRaw = artistTracksMap[normalizedArtist];
                const trackDataMap = {};
                const seen = {};
                
                // Collect all rows for each track to get contributor count and most recent date
                for (let i = 0; i < artistTracksRaw.length; i++) {
                    const row = artistTracksRaw[i];
                    const trackId = row['Track ID'];
                    if (trackId) {
                        if (!trackDataMap[trackId]) {
                            trackDataMap[trackId] = {
                                name: row['Track Name'],
                                artist: row['Artist Name(s)'],
                                year: extractYearFromAddedAt(row['Added At']) || 'N/A',
                                contributors: new Set(),
                                dates: []
                            };
                        }
                        const contributor = row['Added By'];
                        if (contributor) trackDataMap[trackId].contributors.add(contributor);
                        if (row['Added At']) trackDataMap[trackId].dates.push(new Date(row['Added At']));
                    }
                }
                
                // Convert to array and sort
                const consolidatedArray = Object.entries(trackDataMap).map(([trackId, data]) => {
                    const mostRecentDate = data.dates.length > 0 ? new Date(Math.max(...data.dates.map(d => d.getTime()))) : new Date(0);
                    return [
                        data.name,
                        data.artist,
                        trackId,
                        data.year,
                        data.contributors.size,
                        mostRecentDate
                    ];
                }).sort((a, b) => {
                    // Primary sort: by contributor count (descending)
                    if (b[4] !== a[4]) return b[4] - a[4];
                    // Secondary sort: by most recent date (descending)
                    return b[5] - a[5];
                });
                
                artistConsolidatedTracksMap[normalizedArtist] = consolidatedArray;
            });
            
            // Pre-compute consolidated album tracks (deduplicated by track ID) for faster showAlbumDetails
            const albumConsolidatedTracksMap = {};
            Object.keys(albumTracksMap).forEach(normalizedAlbum => {
                const albumTracksRaw = albumTracksMap[normalizedAlbum];
                const trackDataMap = {};
                const seen = {};
                
                // Collect all rows for each track to get contributor count and most recent date
                for (let i = 0; i < albumTracksRaw.length; i++) {
                    const row = albumTracksRaw[i];
                    const trackId = row['Track ID'];
                    if (trackId) {
                        if (!trackDataMap[trackId]) {
                            trackDataMap[trackId] = {
                                name: row['Track Name'],
                                artist: row['Artist Name(s)'],
                                year: extractYearFromAddedAt(row['Added At']) || 'N/A',
                                contributors: new Set(),
                                dates: []
                            };
                        }
                        const contributor = row['Added By'];
                        if (contributor) trackDataMap[trackId].contributors.add(contributor);
                        if (row['Added At']) trackDataMap[trackId].dates.push(new Date(row['Added At']));
                    }
                }
                
                // Convert to array and sort
                const consolidatedArray = Object.entries(trackDataMap).map(([trackId, data]) => {
                    const mostRecentDate = data.dates.length > 0 ? new Date(Math.max(...data.dates.map(d => d.getTime()))) : new Date(0);
                    return [
                        data.name,
                        data.artist,
                        trackId,
                        data.year,
                        data.contributors.size,
                        mostRecentDate
                    ];
                }).sort((a, b) => {
                    // Primary sort: by contributor count (descending)
                    if (b[4] !== a[4]) return b[4] - a[4];
                    // Secondary sort: by most recent date (descending)
                    return b[5] - a[5];
                });
                
                albumConsolidatedTracksMap[normalizedAlbum] = consolidatedArray;
            });
            
            globalData = {
                raw: data,
                artists: countFrequency(data, 'Artist Name(s)', true),
                tracks: countFrequency(data, 'Track Name'),
                albums: countFrequency(data, 'Album Name'),
                genres: countFrequency(data, 'Genre', true),
                contributors: countFrequency(data, 'Added By'),
                years: Object.entries(years).sort((a, b) => b[1] - a[1]),
                addedYears: Object.entries(addedYears).sort((a, b) => b[1] - a[1]),
                contributorYears: contributorYears,
                contributorTopArtists: contributorTopArtists,
                contributorTopGenres: contributorTopGenres,
                contributorPopularity: contributorPopularity,
                trackGenresMap: trackGenresMap,
                trackReleaseMap: trackReleaseMap,
                trackDataMap: trackDataMap,
                trackContributorsMap: trackContributorsMap,
                albumTracksMap: albumTracksMap,
                artistTracksMap: artistTracksMap,
                genreTracksMap: genreTracksMap,
                artistDataMap: artistDataMap,
                artistYears: artistYears,
                albumDataMap: albumDataMap,
                genreDataMap: genreDataMap,
                playlistDataMap: playlistDataMap,
                genreConsolidatedTracksMap: genreConsolidatedTracksMap,
                artistConsolidatedTracksMap: artistConsolidatedTracksMap,
                albumConsolidatedTracksMap: albumConsolidatedTracksMap
            };

            // Calculate total duration
            let totalSeconds = 0;
            data.forEach(row => {
                const durationValue = row['Duration'] || row['Duration (ms)'] || row['duration'] || row['duration_ms'];
                totalSeconds += parseDuration(durationValue);
            });

            renderOverview(totalSeconds);
            renderArtists();
            renderTracks();
            renderAlbums();
            renderGenres();
            renderContributors();
            renderPlaylists();
        }

        function renderOverview(totalSeconds) {
            const data = globalData.raw;
            const html = `
                <div style="background: linear-gradient(135deg, #fff5f3 0%, #fffbf9 100%); border-left: 4px solid #E3836D; padding: 16px; border-radius: 8px; margin-bottom: 20px; display: flex; align-items: center; gap: 12px;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="#E3836D" stroke="#E3836D" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
                    <div style="line-height: 1.2;">
                        <div style="font-size: 14px; font-weight: 600; color: #333; margin-bottom: 2px;">Music Week Archive Statistics</div>
                        <div style="font-size: 12px; color: #666;">Open the menu to explore the archive by album, artist, contributor, genre, partner, playlist, or track!</div>
                    </div>
                </div>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-number">${data.length}</div>
                        <div class="stat-label">Total Tracks</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">${globalData.artists.length}</div>
                        <div class="stat-label">Unique Artists</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">${globalData.albums.length}</div>
                        <div class="stat-label">Albums/Singles</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">${globalData.genres.length}</div>
                        <div class="stat-label">Genres</div>
                    </div>
                    <div class="stat-card duration-card">
                        <div class="stat-number">${formatDuration(totalSeconds)}</div>
                        <div class="stat-label">Total Duration</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">${globalData.contributors.length}</div>
                        <div class="stat-label">Contributors</div>
                    </div>
                </div>

                <h2 style="margin-bottom: 20px;">Top Artists</h2>
                <div class="chart-container">
                    <div class="bar-chart">
                        ${globalData.artists.slice(0, 10).map(([name, count]) => `
                            <div class="bar-item">
                                <div class="bar-label">${name}</div>
                                <div class="bar-wrapper">
                                    <div class="bar-fill" style="width: ${(count / globalData.artists[0][1]) * 100}%">${count}</div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>

                <h2 style="margin-bottom: 20px;">Top Genres</h2>
                <div class="chart-container">
                    <div class="bar-chart">
                        ${globalData.genres.slice(0, 10).map(([name, count]) => `
                            <div class="bar-item">
                                <div class="bar-label">${name}</div>
                                <div class="bar-wrapper">
                                    <div class="bar-fill" style="width: ${(count / globalData.genres[0][1]) * 100}%">${count}</div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
            document.getElementById('overview').innerHTML = html;
        }

        function renderArtists() {
            // Use pre-built artist data map from initialization
            const artistDataMap = globalData.artistDataMap;
            const artistYears = globalData.artistYears;
            
            // Get unique years sorted descending
            const sortedYears = Object.keys(artistYears)
                .map(y => parseInt(y))
                .filter(y => !isNaN(y))
                .sort((a, b) => b - a)
                .map(y => y.toString());
            
            // Get contributor colors
            const colors = [
                '#FF6B6B', '#45B7D1', '#4ECDC4', '#FFA07A', '#BB8FCE',
                '#FFB84D', '#2E86AB', '#A23B72', '#F18F01', '#D62828'
            ];
            
            const html = `
                <div class="filter-buttons">
                    <button class="filter-btn active" onclick="filterArtistsByYear('all')">All</button>
                    ${sortedYears.map(year => `
                        <button class="filter-btn" onclick="filterArtistsByYear('${year}')">${year}</button>
                    `).join('')}
                </div>
                
                <div class="search-box">
                    <input type="text" placeholder="Search artists..." onkeyup="filterArtistCards(this.value)">
                </div>
                
                <div style="background: linear-gradient(135deg, #fff5f3 0%, #fffbf9 100%); border-left: 4px solid #E3836D; padding: 16px; border-radius: 8px; margin-bottom: 20px; display: flex; align-items: center; gap: 12px;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="#E3836D" stroke="#E3836D" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
                    <div style="line-height: 1.2;">
                        <div style="font-size: 14px; font-weight: 600; color: #333; margin-bottom: 2px;">Select an artist to view more tracks</div>
                        <div style="font-size: 12px; color: #666;">Or click an album tag to see more tracks from that album</div>
                    </div>
                </div>

                <div class="cards-grid" id="artists-cards">
                    ${globalData.artists.map(([name, count], idx) => {
                        const data = artistDataMap[name] || {};
                        const topAlbums = Object.entries(data.albums || {})
                            .sort((a, b) => b[1] - a[1])
                            .slice(0, 3)
                            .map(([album]) => album);
                        
                        const topContributors = Object.entries(data.contributors || {})
                            .sort((a, b) => b[1] - a[1])
                            .slice(0, 5);
                        
                        const totalContributors = Object.keys(data.contributors || {}).length;
                        
                        const yearsRange = data.minYear !== Infinity && data.maxYear > 0 
                            ? `${data.minYear} - ${data.maxYear}`
                            : 'N/A';
                        
                        const yearForFilter = (data.peakYear !== null && data.peakYear !== undefined) ? data.peakYear.toString() : 'N/A';
                        
                        return `
                            <div class="card" data-name="${name.toLowerCase()}" data-year="${yearForFilter}" onclick="showArtistDetails('${name.replace(/'/g, "\\'")}')" >
                                <div class="card-top">
                                    <div class="card-info">
                                        <div class="card-artist-name">${name}</div>
                                        <div class="card-track-count">${count} total tracks</div>
                                        <div class="card-unique-count">${(data.uniqueTrackIds && data.uniqueTrackIds.size) || 0} unique</div>
                                    </div>
                                    <div class="card-rank-section">
                                        <div class="card-rank-label">Rank</div>
                                        <div class="card-rank-value">#${idx + 1}</div>
                                    </div>
                                </div>
                                
                                ${topAlbums.length > 0 ? `
                                    <div class="card-albums-row" onclick="event.stopPropagation();">
                                        <div class="card-albums-label">Top Albums</div>
                                        <div class="card-album-tags">
                                            ${topAlbums.map(album => `<span class="card-album-tag" onclick="event.stopPropagation(); showAlbumDetails('${album.replace(/'/g, "\\'")}')" style="cursor: pointer;">${album}</span>`).join('')}
                                        </div>
                                    </div>
                                ` : ''}
                                
                                <div class="card-footer">
                                    ${topContributors.length > 0 ? `
                                        <div class="card-added-by">
                                            <div class="card-contributors-badges">
                                                ${topContributors.map(([contributor, _]) => {
                                                    const parts = contributor.split('.');
                                                    const initials = (parts[0][0] + (parts[1]?.[0] || '')).toUpperCase();
                                                    const color = getContributorColor(contributor);
                                                    return `<span class="contributor-badge" style="background: ${color};">${initials}</span>`;
                                                }).join('')}
                                                ${totalContributors > 5 ? `<span class="contributor-badge" style="background: #999; font-size: 9px; display: flex; align-items: center; justify-content: center;">+${totalContributors - 5}</span>` : ''}
                                            </div>
                                            <span class="card-contributors-text">${totalContributors} contributor${totalContributors !== 1 ? 's' : ''}</span>
                                        </div>
                                    ` : ''}
                                    <div class="card-years-active">${yearsRange}</div>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
            document.getElementById('artists').innerHTML = html;
        }
        
        function formatDate(dateStr) {
            if (!dateStr) return 'N/A';
            const str = String(dateStr).trim();
            
            if (str.match(/^\d{1,2}\/\d{1,2}\/\d{4}$/)) {
                return str;
            }
            
            if (str.match(/^\d{4}-\d{2}-\d{2}/)) {
                const parts = str.split(/[-T\s]/)[0].split('-');
                return `${parts[1]}/${parts[2]}/${parts[0]}`;
            }
            
            if (str.match(/^\d{4}$/)) {
                return str;
            }
            
            return dateStr;
        }
        
        function parseDateForSorting(dateStr) {
            if (!dateStr) return '0000-00-00';
            const str = String(dateStr).trim();
            
            // Already in YYYY-MM-DD format
            if (str.match(/^\d{4}-\d{2}-\d{2}/)) {
                return str.substring(0, 10);
            }
            
            // MM/DD/YYYY format
            if (str.match(/^\d{1,2}\/\d{1,2}\/\d{4}$/)) {
                const parts = str.split('/');
                const month = parts[0].padStart(2, '0');
                const day = parts[1].padStart(2, '0');
                const year = parts[2];
                return `${year}-${month}-${day}`;
            }
            
            // Just a year
            if (str.match(/^\d{4}$/)) {
                return `${str}-00-00`;
            }
            
            return '0000-00-00';
        }
        
        function generateTrackCardsHTML(tracks) {
            let html = '<div class="tracks-cards-grid">';
            
            for (let idx = 0; idx < tracks.length; idx++) {
                const [name, artist, trackId, year, , hasOtherContributors] = tracks[idx];
                console.log(`Track: ${trackId}, hasOtherContributors: ${hasOtherContributors}, fullArray:`, tracks[idx]);
                const spotifyUrl = `https://open.spotify.com/track/${trackId}`;
                const albumArtUrl = `https://raw.githubusercontent.com/mcmillon/music-week-album-art/main/${trackId}.jpg`;
                const album = (globalData.trackDataMap[trackId]?.['Album Name']) || 'Unknown Album';
                
                // Genre tags
                const genres = globalData.trackGenresMap[trackId] || [];
                let genreHtml = '';
                for (let i = 0; i < Math.min(genres.length, 3); i++) {
                    genreHtml += `<span class="track-card-genre-tag" onclick="event.preventDefault(); event.stopPropagation(); showGenreDetails('${genres[i].replace(/'/g, "\\'")}')" style="cursor: pointer;">${genres[i]}</span>`;
                }
                if (!genreHtml) {
                    genreHtml = '<span style="color: #999; font-size: 12px; font-weight: 400;"><span style="display: inline-flex; align-items: center; justify-content: center; width: 18px; height: 18px; background: white; border-radius: 50%; margin-right: 6px; vertical-align: middle; border: 2px solid #E3836D;"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="#E3836D" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg></span>Sorry - this hasn\'t been tagged yet.</span>';
                }
                
                // Contributor badges
                const contributors = globalData.trackContributorsMap[trackId] || [];
                let contributorBadges = '';
                for (let i = 0; i < contributors.length; i++) {
                    const c = contributors[i];
                    const color = getContributorColor(c);
                    const parts = c.split('.');
                    const initials = (parts[0][0] + (parts[1]?.[0] || '')).toUpperCase();
                    contributorBadges += `<span class="track-card-contributor-badge" style="background: ${color};" title="${c}">${initials}</span>`;
                }
                
                const contributorText = contributors.length === 1 
                    ? `Added by ${getFormattedContributorName(contributors[0])}`
                    : `Added by ${contributors.length} contributors`;
                
                const releaseDate = globalData.trackReleaseMap[trackId] 
                    ? formatDate(globalData.trackReleaseMap[trackId])
                    : 'N/A';
                
                html += `<a href="${spotifyUrl}" target="_blank" rel="noopener noreferrer" class="track-card" data-year="${year}" data-name="${name.toLowerCase()}" data-artist="${artist.toLowerCase()}" data-other-contributors="${hasOtherContributors ? 'true' : 'false'}" style="text-decoration: none; color: inherit;">
                <div class="track-card-with-art">
                    <div class="track-card-album-art">
                        <img src="${albumArtUrl}" alt="${album}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 4px;" onerror="this.style.display='none';" loading="lazy">
                    </div>
                    <div class="track-card-content">
                        <div class="track-card-top">
                            <div class="track-card-info">
                                <div class="track-card-name">${name}</div>
                                <div class="track-card-artist">${artist}</div>
                                <div class="track-card-album">${album}</div>
                            </div>
                            <div class="track-card-year-added">
                                <div class="track-card-year-label">Added</div>
                                <div class="track-card-year-value">${year}</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="track-card-genres-row">
                    <div class="contributor-card-info-label">Genres</div>
                    <div class="track-card-genre-tags">${genreHtml}</div>
                </div>
                <div class="track-card-footer">
                    <div class="track-card-added-by">
                        <div class="track-card-contributors-badges">${contributorBadges}</div>
                        <span class="track-card-contributors-text">${contributorText}</span>
                    </div>
                    <div class="track-card-release-date">${releaseDate}</div>
                </div>
            </a>`;
            }
            
            html += '</div>';
            return html;
        }

        function showArtistDetails(artistName) {
            saveScrollPosition('artists');
            switchTab('artists');
            window.scrollTo(0, 0);
            
            setTimeout(() => {
                const normalizedArtistName = normalize(artistName);
                const consolidatedArray = globalData.artistConsolidatedTracksMap[normalizedArtistName] || [];
                
                window.allArtistTracks = consolidatedArray;
                window.currentArtistTracksDisplayed = 20;
                
                const trackCount = consolidatedArray.length;
                const html = `<div style="margin-bottom: 20px;"><button onclick="restoreScrollPosition('artists'); renderArtists();" style="background: #F8F9FA; color: black; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 14px; display: flex; align-items: center; gap: 8px;"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 12H5M12 19l-7-7 7-7"/></svg>Back to Artists</button></div><h2 style="margin-bottom: 20px;">Tracks by "${artistName}" (${trackCount})</h2><div class="search-box"><input type="text" placeholder="Search..." onkeyup="filterTrackCards(this.value)"></div><div id="artist-tracks-container"></div>${trackCount > 20 ? `<div id="load-more-container" style="text-align: center; margin-top: 30px;"><button onclick="loadMoreArtistTracks();" style="background: #E3836D; color: white; border: none; padding: 12px 24px; border-radius: 6px; cursor: pointer;">Load More (${trackCount - 20})</button></div>` : ''}`;
                
                document.getElementById('artists').innerHTML = html;
                
                // Render first batch of cards in next iteration
                setTimeout(() => {
                    const firstBatch = consolidatedArray.slice(0, 20);
                    const trackCardsHtml = generateTrackCardsHTML(firstBatch);
                    document.getElementById('artist-tracks-container').innerHTML = trackCardsHtml;
                    reinitializeLazyLoading();
                }, 0);
            }, 0);
        }
        
        function loadMoreArtistTracks() {
            const nextDisplayCount = window.currentArtistTracksDisplayed + 20;
            const tracksToAdd = window.allArtistTracks.slice(window.currentArtistTracksDisplayed, nextDisplayCount);
            
            const container = document.getElementById('artist-tracks-container');
            container.innerHTML += generateTrackCardsHTML(tracksToAdd);
            
            window.currentArtistTracksDisplayed = nextDisplayCount;
            
            // Update or remove Load More button
            const loadMoreBtn = document.querySelector('button[onclick="loadMoreArtistTracks();"]');
            if (loadMoreBtn) {
                if (window.currentArtistTracksDisplayed >= window.allArtistTracks.length) {
                    loadMoreBtn.parentElement.innerHTML = '';
                } else {
                    loadMoreBtn.textContent = `Load More Tracks (${window.allArtistTracks.length - window.currentArtistTracksDisplayed} remaining)`;
                }
            }
            
            reinitializeLazyLoading();
        }
function getTrackTableHeaderIcon(columnName) {
    const iconSize = 'width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"';
    
    const icons = {
        rank: `<svg ${iconSize}><polyline points="12 5 19 12 12 19"></polyline><polyline points="12 5 5 12 12 19"></polyline></svg>`,
        track: `<svg ${iconSize}><path d="M9 18V5l12-2v13"></path><circle cx="6" cy="18" r="3"></circle><circle cx="18" cy="16" r="3"></circle></svg>`,
        artist: `<svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                <circle cx="12" cy="7" r="4"></circle>
            </svg>`,
        addedby: `<svg ${iconSize}><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>`,
        appearances: `<svg ${iconSize}><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></svg>`
    };
    
    return icons[columnName] || '';
}

function showHeaderTooltip(element) {
    const label = element.getAttribute('data-label');
    
    // Remove any existing tooltip
    const existing = document.querySelector('.header-tooltip');
    if (existing) existing.remove();
    
    // Create tooltip
    const tooltip = document.createElement('div');
    tooltip.className = 'header-tooltip';
    tooltip.textContent = label;
    tooltip.style.cssText = `
        position: fixed;
        background: #333;
        color: white;
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 600;
        z-index: 1000;
        white-space: nowrap;
    `;
    
    document.body.appendChild(tooltip);
    
    // Position below header
    const rect = element.getBoundingClientRect();
    tooltip.style.left = (rect.left + rect.width / 2 - tooltip.offsetWidth / 2) + 'px';
    tooltip.style.top = (rect.bottom + 8) + 'px';
    
    // Auto-remove after 2 seconds
    setTimeout(() => tooltip.remove(), 2000);
}
        function renderTracks() {
            const uniqueTracks = {};
            const trackYears = {};
            
            globalData.raw.forEach(row => {
                const trackId = row['Track ID'];
                const trackName = normalize(row['Track Name']);
                const addedAt = row['Added At'];
                
                if (trackId && trackName) {
                    if (!uniqueTracks[trackId]) {
                        uniqueTracks[trackId] = {
                            name: row['Track Name'],
                            artist: row['Artist Name(s)'],
                            addedAtDates: [],
                            contributorCounts: {},  // Track how many times each contributor added it
                            count: 0
                        };
                    }
                    uniqueTracks[trackId].count++;
                    
                    // Store all added dates to find the earliest
                    if (addedAt) {
                        uniqueTracks[trackId].addedAtDates.push(addedAt);
                    }
                    
                    const contributor = row['Added By'];
                    if (contributor) {
                        uniqueTracks[trackId].contributorCounts[contributor] = (uniqueTracks[trackId].contributorCounts[contributor] || 0) + 1;
                    }
                    
                    if (addedAt) {
                        const year = extractYearFromAddedAt(addedAt);
                        if (year && year !== 'N/A') {
                            trackYears[year] = true;
                        }
                    }
                }
            });
            
            // Convert to array and sort tracks
            const sortedYears = Object.keys(trackYears).sort((a, b) => b - a);
            
            const sortedTracks = Object.entries(uniqueTracks)
                .map(([id, data]) => {
                    // Find the earliest year from all added dates
                    let earliestYear = 'N/A';
                    let mostRecentDate = null;
                    // Count unique dates as the number of times the track was added
                    const uniqueDatesSet = new Set(data.addedAtDates);
                    const timesAdded = uniqueDatesSet.size;
                    
                    if (data.addedAtDates.length > 0) {
                        const yearsForTrack = data.addedAtDates.map(date => extractYearFromAddedAt(date))
                            .filter(year => year !== 'N/A')
                            .map(year => parseInt(year))
                            .sort((a, b) => a - b);
                        if (yearsForTrack.length > 0) {
                            earliestYear = yearsForTrack[0].toString();
                        }
                        // Find the most recent date
                        const sortedDates = data.addedAtDates.sort((a, b) => new Date(b) - new Date(a));
                        mostRecentDate = new Date(sortedDates[0]);
                    }
                    // Get unique contributors list
                    const contributors = Object.keys(data.contributorCounts);
                    return [data.name, data.artist, contributors, data.contributorCounts, earliestYear, timesAdded, id, mostRecentDate];
                })
                .sort((a, b) => {
                    // Primary sort: by number of contributors (descending)
                    if (b[2].length !== a[2].length) return b[2].length - a[2].length;
                    // Secondary sort: by most recent date (descending)
                    if (b[7] && a[7]) return b[7] - a[7];
                    if (b[7]) return -1;
                    if (a[7]) return 1;
                    return 0;
                });
            
            const html = `
    <div class="filter-buttons">
        <button class="filter-btn active" onclick="filterTracksByYear('all')">All</button>
        ${sortedYears.map(year => `
            <button class="filter-btn" onclick="filterTracksByYear('${year}')">${year}</button>
        `).join('')}
    </div>
    
    <div class="search-box">
        <input type="text" id="tracks-search" placeholder="Search tracks..." onkeyup="filterTrackCards(this.value)">
    </div>
    
    <div style="background: linear-gradient(135deg, #fff5f3 0%, #fffbf9 100%); border-left: 4px solid #E3836D; padding: 16px; border-radius: 8px; margin-bottom: 20px; display: flex; align-items: center; gap: 12px;">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="#E3836D" stroke="#E3836D" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
        <div style="line-height: 1.2;">
            <div style="font-size: 14px; font-weight: 600; color: #333; margin-bottom: 2px;">Select a track to open in Spotify</div>
            <div style="font-size: 12px; color: #666;">Or click a genre tag to see more tracks in that category</div>
        </div>
    </div>

    <div class="tracks-cards-grid" id="tracks-cards">
        ${sortedTracks.map(([name, artist, contributors, contributorCounts, year, count, trackId], idx) => {
            
            // Get genres for this track (fast O(1) lookup from pre-built map)
            const genreArray = (globalData.trackGenresMap[trackId] || []).slice(0, 3);
            
            // Get release date (fast O(1) lookup from pre-built map)
            let releaseDate = 'N/A';
            if (globalData.trackReleaseMap[trackId]) {
                releaseDate = formatDate(globalData.trackReleaseMap[trackId]);
            }
            
            // Format contributors with multiplicity indicator
            const contributorBadges = contributors.map(c => {
                const color = getContributorColor(c);
                const parts = c.split('.');
                const initials = (parts[0][0] + (parts[1]?.[0] || '')).toUpperCase();
                const multiplicity = contributorCounts[c] > 1 ? `×${contributorCounts[c]}` : '';
                return `<span class="track-card-contributor-badge" style="background: ${color};" title="${c}${multiplicity ? ' (' + multiplicity + ')' : ''}">${initials}${multiplicity ? '<sup>' + contributorCounts[c] + '</sup>' : ''}</span>`;
            }).join('');
            
            const contributorText = contributors.length === 1 
                ? `Added by ${getFormattedContributorName(contributors[0])}${contributorCounts[contributors[0]] > 1 ? ' (' + contributorCounts[contributors[0]] + 'x)' : ''}`
                : `Added by ${contributors.length} contributors`;
            
            const spotifyUrl = `https://open.spotify.com/track/${trackId}`;
            
            // Build album art URL using new repo (Track ID only)
            const albumArtUrl = `https://raw.githubusercontent.com/mcmillon/music-week-album-art/main/${trackId}.jpg`;
            const trackData = globalData.trackDataMap[trackId];
            const albumName = trackData ? (trackData['Album Name'] || 'Unknown Album') : 'Unknown Album';
            
            return `
                <a href="${spotifyUrl}" target="_blank" rel="noopener noreferrer" class="track-card" data-year="${year}" data-name="${name.toLowerCase()}" data-artist="${artist.toLowerCase()}" style="text-decoration: none; color: inherit;">
                    <div class="track-card-with-art">
                        <div class="track-card-album-art">
                            <img src="${albumArtUrl}" alt="${albumName}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 4px;" onerror="this.style.display='none';" loading="lazy" />
                        </div>
                        <div class="track-card-content">
                            <div class="track-card-top">
                                <div class="track-card-info">
                                    <div class="track-card-name">${name}</div>
                                    <div class="track-card-artist">${artist}</div>
                                    <div class="track-card-album">${albumName}</div>
                                </div>
                                <div class="track-card-year-added">
                                    <div class="track-card-year-label">Added</div>
                                    <div class="track-card-year-value">${year}</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="track-card-genres-row">
                        <div class="contributor-card-info-label">Genres</div>
                        <div class="track-card-genre-tags">
                            ${genreArray.length > 0 ? genreArray.map(genre => `<span class="track-card-genre-tag" onclick="event.preventDefault(); event.stopPropagation(); showGenreDetails('${genre.replace(/'/g, "\\'")}');" style="cursor: pointer;">${genre}</span>`).join('') : '<span style="color: #999; font-size: 12px; font-weight: 400;"><span style="display: inline-flex; align-items: center; justify-content: center; width: 18px; height: 18px; background: white; border-radius: 50%; margin-right: 6px; vertical-align: middle; border: 2px solid #E3836D;"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="#E3836D" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg></span>Sorry - this hasn\'t been tagged yet.</span>'}
                        </div>
                    </div>

                    <div class="track-card-footer">
                        <div class="track-card-added-by">
                            <div class="track-card-contributors-badges">
                                ${contributorBadges}
                            </div>
                            <span class="track-card-contributors-text">${contributorText}</span>
                        </div>
                        <div class="track-card-release-date">${releaseDate}</div>
                    </div>
                </a>
            `;
        }).join('')}
    </div>
`;
document.getElementById('tracks').innerHTML = html;
            reinitializeLazyLoading();
        }
        
        function extractYearFromAddedAt(dateStr) {
            if (!dateStr) return 'N/A';
            const str = String(dateStr).trim();
            
            if (str.match(/^\d{4}$/)) {
                return str;
            } else if (str.match(/^\d{4}-/)) {
                return str.substring(0, 4);
            } else if (str.match(/\/\d{4}$/)) {
                return str.substring(str.length - 4);
            } else if (str.match(/\d{4}/)) {
                const match = str.match(/\d{4}/);
                return match[0];
            }
            return 'N/A';
        }
        
        function filterTracksByYear(year) {
    const cards = document.querySelectorAll('.track-card');
    
    const buttons = document.querySelectorAll('.filter-btn');
    buttons.forEach(btn => btn.classList.remove('active'));
    event.target.classList.add('active');
    
    cards.forEach(card => {
        const cardYear = card.getAttribute('data-year');
        if (year === 'all' || cardYear === year) {
            card.style.display = '';
        } else {
            card.style.display = 'none';
        }
    });
}

        function filterArtistsByYear(year) {
            const cards = document.querySelectorAll('#artists-cards .card');
            
            const buttons = document.querySelectorAll('.filter-btn');
            buttons.forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            cards.forEach(card => {
                const cardYear = card.getAttribute('data-year');
                if (year === 'all' || cardYear === year) {
                    card.style.display = '';
                } else {
                    card.style.display = 'none';
                }
            });
        }

        function renderAlbums() {
            // Use pre-built album data map from initialization
            const albumDataMap = globalData.albumDataMap;
            
            // Build album years map for sorting
            const albumYears = {};
            Object.keys(globalData.albums).forEach(idx => {
                const [albumNameDisplayed] = globalData.albums[idx];
                const normalizedName = normalize(albumNameDisplayed);
                const data = albumDataMap[normalizedName];
                if (data) {
                    albumYears[albumNameDisplayed] = data.year;
                }
            });
            
            const uniqueYears = {};
            Object.values(albumYears).forEach(year => {
                if (year !== 'N/A') {
                    uniqueYears[year] = true;
                }
            });
            const sortedYears = Object.keys(uniqueYears).sort((a, b) => b - a);
            
            const html = `
                <div class="filter-buttons">
                    <button class="filter-btn active" onclick="filterAlbumsByYear('all')">All</button>
                    ${sortedYears.map(year => `
                        <button class="filter-btn" onclick="filterAlbumsByYear('${year}')">${year}</button>
                    `).join('')}
                </div>
                
                <div class="search-box">
                    <input type="text" placeholder="Search albums..." onkeyup="filterAlbumCards(this.value)">
                </div>
                
                <div style="background: linear-gradient(135deg, #fff5f3 0%, #fffbf9 100%); border-left: 4px solid #E3836D; padding: 16px; border-radius: 8px; margin-bottom: 20px; display: flex; align-items: center; gap: 12px;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="#E3836D" stroke="#E3836D" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
                    <div style="line-height: 1.2;">
                        <div style="font-size: 14px; font-weight: 600; color: #333; margin-bottom: 2px;">Select an album to view more tracks</div>
                        <div style="font-size: 12px; color: #666;">Or click a genre tag to see more tracks in that category</div>
                    </div>
                </div>
            `;
            
            document.getElementById('albums').innerHTML = html;
            
            // Build cards HTML in next iteration
            setTimeout(() => {
                let cardsHtml = '<div class="albums-grid" id="albums-cards">';
                
                for (let idx = 0; idx < globalData.albums.length; idx++) {
                    const [albumName, count] = globalData.albums[idx];
                    const normalizedName = normalize(albumName);
                    const data = albumDataMap[normalizedName] || {};
                    
                    const artist = Object.keys(data.artists || {})[0] || 'Unknown';
                    const year = data.year || 'N/A';
                    
                    // Get top genres
                    const topGenres = Object.entries(data.genres || {})
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 3)
                        .map(([genre]) => genre);
                    
                    // Get top contributors
                    const topContributors = Object.entries(data.contributors || {})
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 5);
                    
                    const totalContributors = Object.keys(data.contributors || {}).length;
                    const hasMore = totalContributors > 5;
                    
                    // Build contributor badges
                    let contributorBadges = '';
                    for (let i = 0; i < topContributors.length; i++) {
                        const c = topContributors[i][0];
                        const color = getContributorColor(c);
                        const parts = c.split('.');
                        const initials = (parts[0][0] + (parts[1]?.[0] || '')).toUpperCase();
                        contributorBadges += '<span class="album-card-contributor-badge" style="background: ' + color + ';" title="' + c + '">' + initials + '</span>';
                    }
                    
                    if (hasMore) {
                        const moreCount = totalContributors - 5;
                        contributorBadges += '<span class="album-card-contributor-badge" style="background: #999; font-size: 9px; display: flex; align-items: center; justify-content: center;">+' + moreCount + '</span>';
                    }
                    
                    // Build genre tags
                    let genreTagsHtml = '';
                    for (let i = 0; i < topGenres.length; i++) {
                        genreTagsHtml += '<span class="album-card-genre-tag" onclick="event.preventDefault(); event.stopPropagation(); showGenreDetails(\'' + topGenres[i].replace(/'/g, "\\'") + '\')" style="cursor: pointer;">' + topGenres[i] + '</span>';
                    }
                    if (!genreTagsHtml) {
                        genreTagsHtml = '<span style="color: #999; font-size: 12px; font-weight: 400;"><span style="display: inline-flex; align-items: center; justify-content: center; width: 18px; height: 18px; background: white; border-radius: 50%; margin-right: 6px; vertical-align: middle; border: 2px solid #E3836D;"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="#E3836D" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg></span>Sorry - this hasn\'t been tagged yet.</span>';
                    }
                    
                    const genreSection = '<div class="album-card-genres-row" onclick="event.stopPropagation();"><div class="album-card-genres-label">Genres</div><div class="album-card-genre-tags">' + genreTagsHtml + '</div></div>';
                    
                    const contributorText = totalContributors === 1 
                        ? 'Added by 1 contributor'
                        : 'Added by ' + totalContributors + ' contributors';
                    
                    // Get track ID for this album to pull artwork (use first from trackIds)
                    let trackId = '';
                    if (data.trackIds && data.trackIds.size > 0) {
                        trackId = Array.from(data.trackIds)[0];
                    }
                    
                    const artworkUrl = trackId ? 'https://raw.githubusercontent.com/mcmillon/music-week-album-art/main/' + trackId + '.jpg' : '';
                    const artHtml = artworkUrl 
                        ? '<img src="' + artworkUrl + '" alt="Album Art" style="width: 100%; height: 100%; object-fit: cover; border-radius: 4px; background: #f3f4f6;">'
                        : '<div style="width: 100%; height: 100%; background: #f3f4f6; border-radius: 4px; display: flex; align-items: center; justify-content: center; color: #9ca3af; font-size: 12px;">Album Art</div>';
                    
                    cardsHtml += '<div class="album-card" data-name="' + albumName.toLowerCase() + '" data-year="' + year + '" onclick="showAlbumDetails(\'' + albumName.replace(/'/g, "\\'") + '\')" >' +
                        '<div class="album-card-with-art">' +
                        '<div class="album-card-art">' +
                        artHtml +
                        '</div>' +
                        '<div class="album-card-content">' +
                        '<div class="album-card-top">' +
                        '<div class="album-card-info">' +
                        '<div class="album-card-name">' + albumName + '</div>' +
                        '<div class="album-card-artist">' + artist + '</div>' +
                        '<div class="album-card-track-count">' + count + ' tracks</div>' +
                        '</div>' +
                        '<div class="album-card-year-section">' +
                        '<div class="album-card-year-label">Added</div>' +
                        '<div class="album-card-year-value">' + year + '</div>' +
                        '</div>' +
                        '</div>' +
                        '</div>' +
                        '</div>' +
                        genreSection +
                        '<div class="album-card-footer">' +
                        '<div class="album-card-added-by">' +
                        '<div class="album-card-contributors-badges">' + contributorBadges + '</div>' +
                        '<span class="album-card-contributors-text">' + contributorText + '</span>' +
                        '</div>' +
                        '</div>' +
                        '</div>';
                }
                
                cardsHtml += '</div>';
                document.getElementById('albums').innerHTML += cardsHtml;
            }, 0);
        }
        
        function filterAlbumCards(searchTerm) {
            const cards = document.querySelectorAll('#albums-cards .album-card');
            const filter = searchTerm.toLowerCase();
            
            cards.forEach(card => {
                const name = card.getAttribute('data-name');
                
                if (name.includes(filter)) {
                    card.style.display = '';
                } else {
                    card.style.display = 'none';
                }
            });
        }
        
        function filterAlbumsByYear(year) {
            const cards = document.querySelectorAll('#albums-cards .album-card');
            
            const buttons = document.querySelectorAll('.filter-btn');
            buttons.forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            cards.forEach(card => {
                const cardYear = card.getAttribute('data-year');
                if (year === 'all' || cardYear === year) {
                    card.style.display = '';
                } else {
                    card.style.display = 'none';
                }
            });
        }
        
        function showAlbumDetails(albumName) {
            // Switch tab first for instant visual feedback
            saveScrollPosition('albums');
            switchTab('albums');
            window.scrollTo(0, 0);
            
            // Defer heavy operations to avoid blocking UI
            setTimeout(() => {
                // Use pre-computed consolidated album tracks
                const normalizedAlbumName = normalize(albumName);
                const consolidatedArray = globalData.albumConsolidatedTracksMap[normalizedAlbumName] || [];
                
                // Store globally
                window.allAlbumTracks = consolidatedArray;
                window.currentAlbumTracksDisplayed = 20;
                
                // Build page structure first (fast)
                const trackCount = consolidatedArray.length;
                const html = `<div style="margin-bottom: 20px;"><button onclick="restoreScrollPosition('albums'); renderAlbums();" style="background: #F8F9FA; color: black; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 14px; display: flex; align-items: center; gap: 8px;"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 12H5M12 19l-7-7 7-7"/></svg>Back to Albums</button></div><h2 style="margin-bottom: 20px;">Tracks from "${albumName}" (${trackCount})</h2><div class="search-box"><input type="text" placeholder="Search..." onkeyup="filterTrackCards(this.value)"></div><div id="album-tracks-container"></div>${trackCount > 20 ? `<div id="load-more-container" style="text-align: center; margin-top: 30px;"><button onclick="loadMoreAlbumTracks();" style="background: #E3836D; color: white; border: none; padding: 12px 24px; border-radius: 6px; cursor: pointer;">Load More (${trackCount - 20} remaining)</button></div>` : ''}`;
                
                document.getElementById('albums').innerHTML = html;
                
                // Render first batch of cards in next iteration
                setTimeout(() => {
                    const firstBatch = consolidatedArray.slice(0, 20);
                    const trackCardsHtml = generateTrackCardsHTML(firstBatch);
                    document.getElementById('album-tracks-container').innerHTML = trackCardsHtml;
                    reinitializeLazyLoading();
                }, 0);
            }, 0);
        }
        
        function loadMoreAlbumTracks() {
            const nextDisplayCount = window.currentAlbumTracksDisplayed + 20;
            const tracksToAdd = window.allAlbumTracks.slice(window.currentAlbumTracksDisplayed, nextDisplayCount);
            
            const container = document.getElementById('album-tracks-container');
            container.innerHTML += generateTrackCardsHTML(tracksToAdd);
            
            window.currentAlbumTracksDisplayed = nextDisplayCount;
            
            // Update or remove Load More button
            const loadMoreBtn = document.querySelector('button[onclick="loadMoreAlbumTracks();"]');
            if (loadMoreBtn) {
                if (window.currentAlbumTracksDisplayed >= window.allAlbumTracks.length) {
                    loadMoreBtn.parentElement.innerHTML = '';
                } else {
                    loadMoreBtn.textContent = `Load More Tracks (${window.allAlbumTracks.length - window.currentAlbumTracksDisplayed} remaining)`;
                }
            }
            
            reinitializeLazyLoading();
        }

        function renderGenres() {
            if (globalData.genres.length === 0) {
                document.getElementById('genres').innerHTML = `
                    <div class="empty-state">
                        <p style="font-size: 18px; color: #666;">No genre data found in CSV</p>
                        <p style="margin-top: 10px; font-size: 14px;">Make sure your CSV has a "Genre" column</p>
                    </div>
                `;
                return;
            }
            
            // Use pre-built genre data map from initialization
            const genreDataMap = globalData.genreDataMap;
            
            let cardsHtml = '<div class="search-box"><input type="text" placeholder="Search genres..." onkeyup="filterGenreCards(this.value)"></div><div style="background: linear-gradient(135deg, #fff5f3 0%, #fffbf9 100%); border-left: 4px solid #E3836D; padding: 16px; border-radius: 8px; margin-bottom: 20px; display: flex; align-items: center; gap: 12px;"><svg width="20" height="20" viewBox="0 0 24 24" fill="#E3836D" stroke="#E3836D" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg><div style="line-height: 1.2;"><div style="font-size: 14px; font-weight: 600; color: #333; margin-bottom: 2px;">Select a genre to view more tracks</div><div style="font-size: 12px; color: #666;">Or click an artist to view more tracks by that artist</div></div></div><div class="genres-grid" id="genres-cards">';
            
            for (let idx = 0; idx < globalData.genres.length; idx++) {
                const [name, count] = globalData.genres[idx];
                const data = genreDataMap[name] || {};
                
                // Get top 3 artists for this genre
                const topArtists = Object.entries(data.artists || {})
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 3)
                    .map(([artist]) => artist);
                
                // Get top contributors
                const topContributors = Object.entries(data.contributors || {})
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 5);
                
                // Build contributor badges
                let contributorBadges = '';
                for (let i = 0; i < topContributors.length; i++) {
                    const c = topContributors[i][0];
                    const color = getContributorColor(c);
                    const parts = c.split('.');
                    const initials = (parts[0][0] + (parts[1]?.[0] || '')).toUpperCase();
                    contributorBadges += '<span class="genre-card-contributor-badge" style="background: ' + color + ';" title="' + c + '">' + initials + '</span>';
                }
                
                // Check if there are more contributors
                const totalContributors = Object.keys(data.contributors || {}).length;
                const hasMore = totalContributors > 5;
                if (hasMore) {
                    const moreCount = totalContributors - 5;
                    contributorBadges += '<span class="genre-card-contributor-badge" style="background: #999; font-size: 9px; display: flex; align-items: center; justify-content: center;">+' + moreCount + '</span>';
                }
                
                const percentage = ((count / globalData.raw.length) * 100).toFixed(1);
                const contributorText = totalContributors === 1 
                    ? totalContributors + ' contributor'
                    : totalContributors + ' contributors';
                
                let artistTagsHtml = '';
                for (let i = 0; i < topArtists.length; i++) {
                    artistTagsHtml += '<span class="genre-card-artist-tag" onclick="event.preventDefault(); event.stopPropagation(); showArtistDetails(\'' + topArtists[i].replace(/'/g, "\\'") + '\')" style="cursor: pointer;">' + topArtists[i] + '</span>';
                }
                
                const topArtistsSection = topArtists.length > 0 
                    ? '<div class="genre-card-artists-row" onclick="event.stopPropagation();"><div class="genre-card-artists-label">Top Artists</div><div class="genre-card-artist-tags">' + artistTagsHtml + '</div></div>'
                    : '';
                
                cardsHtml += '<div class="genre-card" data-name="' + name.toLowerCase() + '" onclick="showGenreDetails(\'' + name.replace(/'/g, "\\'") + '\')" >' +
                    '<div class="genre-card-top">' +
                    '<div class="genre-card-info">' +
                    '<div class="genre-card-name">' + name + '</div>' +
                    '<div class="genre-card-track-count">' + count + ' tracks</div>' +
                    '<div class="genre-card-percentage">' + percentage + '% of Music Week</div>' +
                    '</div>' +
                    '<div class="genre-card-rank-section">' +
                    '<div class="genre-card-rank-label">Rank</div>' +
                    '<div class="genre-card-rank-value">#' + (idx + 1) + '</div>' +
                    '</div>' +
                    '</div>' +
                    topArtistsSection +
                    '<div class="genre-card-footer">' +
                    '<div class="genre-card-added-by">' +
                    '<div class="genre-card-contributors-badges">' + contributorBadges + '</div>' +
                    '<span class="genre-card-contributors-text">' + contributorText + '</span>' +
                    '</div>' +
                    '</div>' +
                    '</div>';
            }
            
            cardsHtml += '</div>';
            document.getElementById('genres').innerHTML = cardsHtml;
        }
        
        function filterGenreCards(searchTerm) {
            const cards = document.querySelectorAll('#genres-cards .genre-card');
            const filter = searchTerm.toLowerCase();
            
            cards.forEach(card => {
                const name = card.getAttribute('data-name');
                
                if (name.includes(filter)) {
                    card.style.display = '';
                } else {
                    card.style.display = 'none';
                }
            });
        }
        
        function showGenreDetails(genreName) {
            switchTab('genres');
            saveScrollPosition('genres');
            window.scrollTo(0, 0);
            window.previousPage = 'genres';
            
            setTimeout(() => {
                const normalizedGenreName = normalize(genreName);
                // Use pre-computed consolidated tracks instead of computing on-the-fly
                const consolidatedArray = globalData.genreConsolidatedTracksMap[normalizedGenreName] || [];
                
                window.allGenreTracks = consolidatedArray;
                window.currentGenreTracksDisplayed = 20;
                
                const trackCount = consolidatedArray.length;
                const html = `<div style="margin-bottom: 20px;"><button onclick="restoreScrollPosition('genres'); goBackToPreviousPage();" style="background: #F8F9FA; color: black; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; display: flex; align-items: center; gap: 8px;"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 12H5M12 19l-7-7 7-7"/></svg>Back to Genres</button></div><h2 style="margin-bottom: 20px;">Tracks: "${genreName}" (${trackCount})</h2><div class="search-box"><input type="text" placeholder="Search..." onkeyup="filterTrackCards(this.value)"></div><div id="genre-tracks-container"></div>${trackCount > 20 ? `<div id="load-more-container" style="text-align: center; margin-top: 30px;"><button onclick="loadMoreGenreTracks();" style="background: #E3836D; color: white; border: none; padding: 12px 24px; border-radius: 6px; cursor: pointer;">Load More (${trackCount - 20})</button></div>` : ''}`;
                
                document.getElementById('genres').innerHTML = html;
                
                // Render first batch of cards in next iteration
                setTimeout(() => {
                    const firstBatch = consolidatedArray.slice(0, 20);
                    const trackCardsHtml = generateTrackCardsHTML(firstBatch);
                    document.getElementById('genre-tracks-container').innerHTML = trackCardsHtml;
                    reinitializeLazyLoading();
                }, 0);
            }, 0);
        }
        
        function loadMoreGenreTracks() {
            const nextDisplayCount = window.currentGenreTracksDisplayed + 20;
            const tracksToAdd = window.allGenreTracks.slice(window.currentGenreTracksDisplayed, nextDisplayCount);
            
            const container = document.getElementById('genre-tracks-container');
            container.innerHTML += generateTrackCardsHTML(tracksToAdd);
            
            window.currentGenreTracksDisplayed = nextDisplayCount;
            
            // Update or remove Load More button
            const loadMoreBtn = document.querySelector('button[onclick="loadMoreGenreTracks();"]');
            if (loadMoreBtn) {
                if (window.currentGenreTracksDisplayed >= window.allGenreTracks.length) {
                    loadMoreBtn.parentElement.innerHTML = '';
                } else {
                    loadMoreBtn.textContent = `Load More Tracks (${window.allGenreTracks.length - window.currentGenreTracksDisplayed} remaining)`;
                }
            }
            
            reinitializeLazyLoading();
        }
        
        function goBackToPreviousPage() {
            restoreScrollPosition('genres');
            renderGenres();
        }

        function renderPlaylists() {
            // Use pre-built playlist data map from initialization
            const playlistDataMap = globalData.playlistDataMap;
            const GITHUB_BASE_URL = "https://raw.githubusercontent.com/mcmillon/music-week-archive/main/covers";
            
            // Convert to array and sort by year (most recent first)
            const playlists = Object.values(playlistDataMap).map(p => ({
                name: p.name,
                uri: p.uri,
                contributors: Array.from(p.contributors).sort(),
                years: Array.from(p.years).sort((a, b) => b - a),
                trackCount: p.trackCount
            })).sort((a, b) => {
                // Sort by most recent year first
                const yearA = a.years[0] || '0000';
                const yearB = b.years[0] || '0000';
                return yearB.localeCompare(yearA);
            });
            
            if (playlists.length === 0) {
                document.getElementById('playlists').innerHTML = `
                    <div class="empty-state">
                        <p style="font-size: 18px; color: #666;">No playlist data found in CSV</p>
                        <p style="margin-top: 10px; font-size: 14px;">Make sure your CSV has "Playlist Name" and "Playlist URI" columns</p>
                    </div>
                `;
                return;
            }
            
            // Get unique contributors and years for filters
            const allContributors = new Set();
            const allYears = new Set();
            playlists.forEach(p => {
                p.contributors.forEach(c => allContributors.add(c));
                p.years.forEach(y => allYears.add(y));
            });
            
            const sortedContributors = Array.from(allContributors).sort();
            const sortedYears = Array.from(allYears).sort((a, b) => b - a);
            
            // Store playlists in global data for detail view
            globalData.playlists = playlists;
            
            const html = `
                <h2 style="margin-bottom: 20px;">All Playlists (${playlists.length})</h2>
                
                <div style="margin-bottom: 20px; display: flex; gap: 20px; flex-wrap: wrap; align-items: center;">
                    <div>
                        <label style="font-weight: 600; margin-right: 10px;">Filter by Contributor:</label>
                        <select id="playlistContributorFilter" onchange="filterPlaylistsByContributor(this.value)" style="padding: 8px 12px; border: 2px solid #E3836D; border-radius: 6px; font-size: 14px; cursor: pointer;">
                            <option value="all">All Contributors</option>
                            ${sortedContributors.map(c => `<option value="${c}">${c}</option>`).join('')}
                        </select>
                    </div>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <h3 style="font-size: 14px; font-weight: 600; margin-bottom: 10px;">Filter by Year:</h3>
                    <div class="filter-buttons">
                        <button class="filter-btn active" onclick="filterPlaylistsByYear('all')">All</button>
                        ${sortedYears.map(y => `
                            <button class="filter-btn" onclick="filterPlaylistsByYear('${y}')">${y}</button>
                        `).join('')}
                    </div>
                </div>
                
                <div class="search-box">
                    <input type="text" placeholder="Search playlists..." onkeyup="filterTable(this, 'playlists-table')">
                </div>
                <div style="background: linear-gradient(135deg, #fff5f3 0%, #fffbf9 100%); border-left: 4px solid #E3836D; padding: 16px; border-radius: 8px; margin-bottom: 20px; display: flex; align-items: center; gap: 12px;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="#E3836D" stroke="#E3836D" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
                    <div style="line-height: 1.2;">
                        <div style="font-size: 14px; font-weight: 600; color: #333; margin-bottom: 2px;">Select any playlist</div>
                        <div style="font-size: 12px; color: #666;">Open in Spotify to listen</div>
                    </div>
                </div>
                <div class="grid">
  ${playlists.map((playlist, idx) => {
    const playlistId = playlist.uri.split(':').pop();
    const spotifyUrl = `https://open.spotify.com/playlist/${playlistId}`;
    const imageUrl = `${GITHUB_BASE_URL}/${playlist.uri}.jfif`;
    const contributorBadges = playlist.contributors.map(c => formatContributorWithName(c)).join(' ');
    
    return `
      <a href="${spotifyUrl}" target="_blank" rel="noopener noreferrer" class="card" data-name="${playlist.name}" data-contributors="${playlist.contributors.join(',')}" data-years="${playlist.years.join(',')}">
        <div class="card-image">
          <img src="${imageUrl}" alt="${playlist.name}" onerror="this.style.display='none'; this.parentElement.textContent='No Image';">
          <div class="card-contributor-badges-overlay">${playlist.contributors.map(c => {
            const parts = c.split('.');
            const initials = (parts[0][0] + (parts[1]?.[0] || '')).toUpperCase();
            const color = getContributorColor(c);
            return `<span class="contributor-badge" style="background: ${color};">${initials}</span>`;
          }).join('')}</div>
        </div>
        <div class="card-info">
          <div class="card-title">${playlist.name}</div>
          <div class="card-contributor-names">${playlist.contributors.map(c => {
            const parts = c.split('.');
            const firstName = parts[0] ? parts[0].charAt(0).toUpperCase() + parts[0].slice(1) : '';
            const lastName = parts[1] ? parts[1].charAt(0).toUpperCase() + parts[1].slice(1) : '';
            return lastName ? `${firstName} ${lastName}` : firstName;
          }).join(', ')}</div>
          <div class="card-year">${playlist.years.join(', ')}</div>
        </div>
      </a>
    `;
  }).join('')}
</div>
            `;
            
            document.getElementById('playlists').innerHTML = html;
            
            // Store current filters in global variable
            window.playlistFilters = {
                contributor: 'all',
                year: 'all'
            };
        }
        
        function sortPlaylistsByColumn(column) {
            const table = document.getElementById('playlists-table');
            const tbody = table.getElementsByTagName('tbody')[0];
            const rows = Array.from(tbody.getElementsByTagName('tr'));
            const headers = table.getElementsByTagName('th');
            
            let clickedHeader = null;
            for (let i = 0; i < headers.length; i++) {
                if (headers[i].onclick && headers[i].onclick.toString().includes(column)) {
                    clickedHeader = headers[i];
                    break;
                }
            }
            
            let isAsc = true;
            if (clickedHeader) {
                if (clickedHeader.classList.contains('asc')) {
                    isAsc = false;
                    clickedHeader.classList.remove('asc');
                    clickedHeader.classList.add('desc');
                } else {
                    isAsc = true;
                    clickedHeader.classList.remove('desc');
                    clickedHeader.classList.add('asc');
                }
                
                for (let i = 0; i < headers.length; i++) {
                    if (headers[i] !== clickedHeader) {
                        headers[i].classList.remove('asc', 'desc');
                    }
                }
            }
            
            rows.sort((a, b) => {
                let valA = '';
                let valB = '';
                
                if (column === 'name') {
                    valA = (a.getAttribute('data-name') || '').toLowerCase();
                    valB = (b.getAttribute('data-name') || '').toLowerCase();
                } else if (column === 'contributor') {
                    valA = (a.getAttribute('data-contributors') || '').toLowerCase();
                    valB = (b.getAttribute('data-contributors') || '').toLowerCase();
                } else if (column === 'year') {
                    valA = a.getAttribute('data-years') || '0000';
                    valB = b.getAttribute('data-years') || '0000';
                } else if (column === 'tracks') {
                    valA = parseInt(a.getAttribute('data-tracks') || '0');
                    valB = parseInt(b.getAttribute('data-tracks') || '0');
                    
                    if (isAsc) {
                        return valA - valB;
                    } else {
                        return valB - valA;
                    }
                }
                
                if (isAsc) {
                    return valA.localeCompare(valB);
                } else {
                    return valB.localeCompare(valA);
                }
            });
            
rows.forEach((row) => {
    tbody.appendChild(row);
    const originalIndex = parseInt(row.getAttribute('data-original-index'));
    row.cells[0].textContent = originalIndex + 1;  // Uses original index
});
        }
        
        function filterPlaylistsByContributor(contributor) {
            window.playlistFilters.contributor = contributor;
            applyPlaylistFilters();
        }
        
        function filterPlaylistsByYear(year) {
            window.playlistFilters.year = year;
            
            // Update button states
            const buttons = document.querySelectorAll('.filter-buttons .filter-btn');
            buttons.forEach(btn => {
                if (btn.onclick && btn.onclick.toString().includes('filterPlaylistsByYear')) {
                    btn.classList.remove('active');
                    if (btn.textContent.trim() === year || (year === 'all' && btn.textContent.includes('All'))) {
                        btn.classList.add('active');
                    }
                }
            });
            
            applyPlaylistFilters();
        }
        
        function applyPlaylistFilters() {
    const contributorFilter = window.playlistFilters.contributor;
    const yearFilter = window.playlistFilters.year;
    const cards = document.querySelectorAll('.card');
    
    cards.forEach(card => {
        const playlistName = card.getAttribute('data-name') || '';
        const contributors = (card.getAttribute('data-contributors') || '').split(',');
        const years = (card.getAttribute('data-years') || '').split(',');
        
        let showCard = true;
        
        if (contributorFilter !== 'all' && !contributors.includes(contributorFilter)) {
            showCard = false;
        }
        
        if (yearFilter !== 'all' && !years.includes(yearFilter)) {
            showCard = false;
        }
        
        card.style.display = showCard ? '' : 'none';
    });
}

function formatYearsActive(yearList) {
    if (!yearList) return 'N/A';
    
    const years = yearList.split(', ');
    const allYears = ['2018', '2019', '2020', '2021', '2022', '2023', '2024'];
    
    // Check if contributor has been active in all years
    const isAllYears = allYears.every(year => years.includes(year));
    
    if (isAllYears) {
        return '<span style="font-weight: 600; color: var(--accent-pop);">🏆 All Years</span>';
    }
    
    // Format years as two-digit (e.g., '24 for 2024)
    return years.map(year => "'" + year.slice(-2)).join(', ');
}
        
        function renderContributors() {
            if (globalData.contributors.length === 0) {
                document.getElementById('contributors').innerHTML = `
                    <div class="empty-state">
                        <p style="font-size: 18px; color: #666;">No contributor data found in CSV</p>
                        <p style="margin-top: 10px; font-size: 14px;">Make sure your CSV has an "Added By" column</p>
                    </div>
                `;
                return;
            }
            
            const top5Genres = globalData.genres.slice(0, 5).map(g => g[0]);
            
            const tracksByContributor = {};
            
            globalData.raw.forEach(row => {
                const contributor = normalize(row['Added By']);
                const trackId = row['Track ID'];
                
                if (contributor && trackId) {
                    if (!tracksByContributor[contributor]) {
                        tracksByContributor[contributor] = new Set();
                    }
                    tracksByContributor[contributor].add(trackId);
                }
            });
            
            const overlaps = [];
            const contributors = Object.keys(tracksByContributor);
            for (let i = 0; i < contributors.length; i++) {
                for (let j = i + 1; j < contributors.length; j++) {
                    const c1 = contributors[i];
                    const c2 = contributors[j];
                    const tracks1 = tracksByContributor[c1];
                    const tracks2 = tracksByContributor[c2];
                    const sharedTrackIds = [...tracks1].filter(t => tracks2.has(t));
                    const overlap = sharedTrackIds.length;
                    
                    if (overlap > 0) {
                        // Get years for shared tracks
                        const sharedYears = new Set();
                        globalData.raw.forEach(row => {
                            if (sharedTrackIds.includes(row['Track ID'])) {
                                const year = extractYearFromAddedAt(row['Added At']);
                                if (year && year !== 'N/A') {
                                    sharedYears.add(year);
                                }
                            }
                        });
                        
                        overlaps.push({ c1, c2, overlap, years: Array.from(sharedYears).sort((a, b) => b - a) });
                    }
                }
            }
            overlaps.sort((a, b) => b.overlap - a.overlap);
            
            const popularityRankings = globalData.contributors.map(([name]) => {
                const popData = globalData.contributorPopularity[name];
                const avgPop = popData ? (popData.total / popData.count) : 0;
                return { name, avgPop, count: popData ? popData.count : 0 };
            }).sort((a, b) => a.avgPop - b.avgPop);
            
            // Get unique years for overlap filter
            const overlapYears = new Set();
            globalData.raw.forEach(row => {
                const addedAt = row['Added At'];
                if (addedAt) {
                    const year = extractYearFromAddedAt(addedAt);
                    if (year && year !== 'N/A') {
                        overlapYears.add(year);
                    }
                }
            });
            const sortedOverlapYears = Array.from(overlapYears).sort((a, b) => b - a);
            
            const html = `
<div class="search-box">
    <input type="text" id="contributor-search" placeholder="Search contributors..." onkeyup="filterContributorCards(this.value)">
</div>
<div style="background: linear-gradient(135deg, #fff5f3 0%, #fffbf9 100%); border-left: 4px solid #E3836D; padding: 16px; border-radius: 8px; margin-bottom: 20px; display: flex; align-items: center; gap: 12px;">
    <svg width="20" height="20" viewBox="0 0 24 24" fill="#E3836D" stroke="#E3836D" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
    <div style="line-height: 1.2;">
        <div style="font-size: 14px; font-weight: 600; color: #333; margin-bottom: 2px;">Select a contributor</div>
        <div style="font-size: 12px; color: #666;">View tracks they've added to Music Week</div>
    </div>
</div>

<div class="contributors-cards-grid" id="contributors-cards">
    ${globalData.contributors.map(([name, count], idx) => {
const years = globalData.contributorYears[name] || {};
const yearList = Object.keys(years).sort((a, b) => a - b); // Sort ascending to find first year
const allYears = ['2018', '2019', '2020', '2021', '2022', '2023', '2024'];

// Check if contributor is on a streak (2 consecutive years: most recent year and prior year)
let isConsecutive = false;
if (yearList.length >= 2) {
    const lastYear = parseInt(yearList[yearList.length - 1]);
    const secondLastYear = parseInt(yearList[yearList.length - 2]);
    
    // Show flame if they've contributed in 2 consecutive years (most recent and prior)
    isConsecutive = (lastYear - secondLastYear) === 1;
}
        
        const artistCounts = globalData.contributorTopArtists[name] || {};
        const topArtist = Object.entries(artistCounts)
            .sort((a, b) => b[1] - a[1])[0];
        const topArtistName = topArtist ? `${topArtist[0]} (${topArtist[1]})` : 'N/A';
        
        const genreCounts = globalData.contributorTopGenres[name] || {};
        const topGenreOverall = Object.entries(genreCounts)
            .sort((a, b) => b[1] - a[1])[0];
        const topGenreOverallName = topGenreOverall ? topGenreOverall[0] : 'N/A';
        const topGenreOverallCount = topGenreOverall ? topGenreOverall[1] : 0;
        
        const top5Genres = globalData.genres.slice(0, 5).map(g => g[0]);
        const topGenreOutsideTop5 = Object.entries(genreCounts)
            .filter(([genre]) => !top5Genres.includes(genre))
            .sort((a, b) => b[1] - a[1])[0];
        const topGenreName = topGenreOutsideTop5 ? topGenreOutsideTop5[0] : 'N/A';
        const topGenreCount = topGenreOutsideTop5 ? topGenreOutsideTop5[1] : 0;
        
        const color = getContributorColor(name);
        const parts = name.split('.');
        const initials = (parts[0][0] + (parts[1]?.[0] || '')).toUpperCase();
        
        // Format display name inline
        let firstName = parts[0] ? parts[0].charAt(0).toUpperCase() + parts[0].slice(1) : '';
        let lastName = parts[1] ? parts[1].charAt(0).toUpperCase() + parts[1].slice(1) : '';
        if (name === 'trey.mcmillon') {
            firstName = 'Trey';
            lastName = 'McMillon';
        }
        const displayName = lastName ? `${firstName} ${lastName}` : firstName;
        
        const popData = globalData.contributorPopularity[name];
        const avgPop = popData ? Math.round(popData.total / popData.count) : 0;
        
        return `
            <div class="contributor-card" onclick="showContributorDetails('${name.replace(/'/g, "\\'")}')" data-name="${name}">
                <div class="contributor-card-top">
                    <div class="contributor-card-left">
                        <div class="contributor-card-badge" style="background: ${color};">
                            ${initials}
                        </div>
                        <div class="contributor-card-name-col">
                            <div class="contributor-card-name">${displayName}</div>
                            <div class="contributor-card-tracks-pct">
                                <span>${count} Tracks</span>
                            </div>
                        </div>
                    </div>
                    <div class="contributor-card-right">
                        <div class="contributor-card-active-label">Active</div>
                        <div class="contributor-card-active-value">
                            ${isConsecutive ? `<svg class="contributor-card-flame" viewBox="0 0 24 24">
                                <path d="M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.153.433-2.294 1-3a2.5 2.5 0 0 0 2.5 2.5z"/>
                            </svg>` : ''}
                            <span>${yearList.length} Yr${yearList.length > 1 ? 's' : ''}</span>
                        </div>
                    </div>
                </div>

                <div class="contributor-card-info-grid">
                    <div class="contributor-card-column">
                        <div class="contributor-card-info-item">
                            <div class="contributor-card-info-label">Top Genre</div>
                            <div class="contributor-card-info-value">${topGenreOverallName} (${topGenreOverallCount})</div>
                        </div>
                    </div>
                    <div class="contributor-card-column">
                        <div class="contributor-card-info-item">
                            <div class="contributor-card-info-label">Niche Genre</div>
                            <div class="contributor-card-info-value">${topGenreName} (${topGenreCount})</div>
                        </div>
                    </div>
                    <div class="contributor-card-column">
                        <div class="contributor-card-info-item">
                            <div class="contributor-card-info-label">Top Artist</div>
                            <div class="contributor-card-info-value">${topArtistName}</div>
                        </div>
                    </div>
                </div>

                <div class="contributor-card-footer">
                    <span class="contributor-card-rank">#${idx + 1}</span>
                </div>
            </div>
        `;
    }).join('')}
</div>
            `;
            
            document.getElementById('contributors').innerHTML = html;
        }
        
        function renderPartners() {
            const tracksByContributor = {};
            
            globalData.raw.forEach(row => {
                const contributor = normalize(row['Added By']);
                const trackId = row['Track ID'];
                
                if (contributor && trackId) {
                    if (!tracksByContributor[contributor]) {
                        tracksByContributor[contributor] = new Set();
                    }
                    tracksByContributor[contributor].add(trackId);
                }
            });
            
            const overlaps = [];
            const contributors = Object.keys(tracksByContributor);
            for (let i = 0; i < contributors.length; i++) {
                for (let j = i + 1; j < contributors.length; j++) {
                    const c1 = contributors[i];
                    const c2 = contributors[j];
                    const tracks1 = tracksByContributor[c1];
                    const tracks2 = tracksByContributor[c2];
                    const sharedTrackIds = [...tracks1].filter(t => tracks2.has(t));
                    const overlap = sharedTrackIds.length;
                    
                    if (overlap > 0) {
                        // Get years and artists for shared tracks
                        const sharedYears = new Set();
                        const artistCounts = {};
                        globalData.raw.forEach(row => {
                            if (sharedTrackIds.includes(row['Track ID'])) {
                                const year = extractYearFromAddedAt(row['Added At']);
                                if (year && year !== 'N/A') {
                                    sharedYears.add(year);
                                }
                                const artistNames = row['Artist Name(s)'] || '';
                                const artists = artistNames ? String(artistNames).split(/[;,&]/).map(a => a.trim()).filter(a => a) : [];
                                if (artists.length === 0) {
                                    artistCounts['Unknown'] = (artistCounts['Unknown'] || 0) + 1;
                                } else {
                                    artists.forEach(artist => {
                                        artistCounts[artist] = (artistCounts[artist] || 0) + 1;
                                    });
                                }
                            }
                        });
                        
                        const topArtists = Object.entries(artistCounts)
                            .sort((a, b) => b[1] - a[1])
                            .slice(0, 3)
                            .map(entry => entry[0]);
                        
                        overlaps.push({ c1, c2, overlap, years: Array.from(sharedYears).sort((a, b) => b - a), topArtists });
                    }
                }
            }
            overlaps.sort((a, b) => b.overlap - a.overlap);
            
            let cardsHtml = '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 16px; margin-bottom: 40px;" id="overlap-cards-container">';
            
            for (let idx = 0; idx < overlaps.length; idx++) {
                const item = overlaps[idx];
                const c1Parts = item.c1.split('.');
                const c1Initials = (c1Parts[0][0] + (c1Parts[1]?.[0] || '')).toUpperCase();
                const c1Color = getContributorColor(item.c1);
                let c1FirstName = c1Parts[0] ? c1Parts[0].charAt(0).toUpperCase() + c1Parts[0].slice(1) : '';
                let c1LastName = c1Parts[1] ? c1Parts[1].charAt(0).toUpperCase() + c1Parts[1].slice(1) : '';
                if (item.c1 === 'trey.mcmillon') { c1FirstName = 'Trey'; c1LastName = 'McMillon'; }
                
                const c2Parts = item.c2.split('.');
                const c2Initials = (c2Parts[0][0] + (c2Parts[1]?.[0] || '')).toUpperCase();
                const c2Color = getContributorColor(item.c2);
                let c2FirstName = c2Parts[0] ? c2Parts[0].charAt(0).toUpperCase() + c2Parts[0].slice(1) : '';
                let c2LastName = c2Parts[1] ? c2Parts[1].charAt(0).toUpperCase() + c2Parts[1].slice(1) : '';
                if (item.c2 === 'trey.mcmillon') { c2FirstName = 'Trey'; c2LastName = 'McMillon'; }
                
                // Check if either full name is too long; if so, use first names for both
                const c1FullName = c1LastName ? c1FirstName + ' ' + c1LastName : c1FirstName;
                const c2FullName = c2LastName ? c2FirstName + ' ' + c2LastName : c2FirstName;
                const shouldCompact = c1FullName.length > 9 || c2FullName.length > 9;
                
                const c1DisplayName = shouldCompact ? c1FirstName : c1FullName;
                const c2DisplayName = shouldCompact ? c2FirstName : c2FullName;
                
                cardsHtml += '<div class="overlap-card partner-card" data-c1="' + item.c1 + '" data-c2="' + item.c2 + '" style="cursor: pointer; display: flex; flex-direction: column; justify-content: space-between;">';
                
                // Top section with names on left and shared count on right
                cardsHtml += '<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">';
                
                // Left side: Partner names with Venn diagram badges
                cardsHtml += '<div style="display: flex; align-items: center; gap: 8px; flex: 1; min-width: 0; overflow: hidden;">';
                cardsHtml += '<div style="font-size: 15px; font-weight: 700; color: #212529; text-align: right; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">' + c1DisplayName + '</div>';
                
                // Venn diagram badges (slight overlap for visual connection)
                cardsHtml += '<div style="display: flex; align-items: center; justify-content: center; position: relative; width: 48px; height: 32px; flex-shrink: 0;">';
                cardsHtml += '<div class="overlap-badge" style="background: ' + c1Color + '; position: absolute; left: 0; z-index: 2; width: 28px; height: 28px; font-size: 10px; display: flex; align-items: center; justify-content: center;">' + c1Initials + '</div>';
                cardsHtml += '<div class="overlap-badge" style="background: ' + c2Color + '; position: absolute; right: 0; z-index: 2; width: 28px; height: 28px; font-size: 10px; display: flex; align-items: center; justify-content: center;">' + c2Initials + '</div>';
                cardsHtml += '</div>';
                
                cardsHtml += '<div style="font-size: 15px; font-weight: 700; color: #212529; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">' + c2DisplayName + '</div>';
                cardsHtml += '</div>';
                
                // Right side: Shared count with track card year styling
                cardsHtml += '<div class="track-card-year-added" style="padding-left: 12px; border-left: 1px solid #f0f0f0;">';
                cardsHtml += '<div class="track-card-year-label">Shared</div>';
                cardsHtml += '<div class="track-card-year-value">' + item.overlap + '</div>';
                cardsHtml += '</div></div>';
                
                // Artists section
                if (item.topArtists && item.topArtists.length > 0) {
                    cardsHtml += '<div style="margin-bottom: 10px; margin-top: 12px; padding-top: 12px; padding-bottom: 10px; border-top: 1px solid #f0f0f0; border-bottom: 1px solid #f0f0f0;">';
                    cardsHtml += '<div style="font-size: 10px; color: #999; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 6px;">Top Artists</div>';
                    cardsHtml += '<div class="track-card-genre-tags">';
                    item.topArtists.forEach(artist => {
                        cardsHtml += '<span class="track-card-genre-tag" onclick="event.stopPropagation(); showArtistDetails(\'' + artist.replace(/'/g, "\\'") + '\');" style="cursor: pointer;">' + artist + '</span>';
                    });
                    cardsHtml += '</div></div>';
                }
                
                // Years section
                if (item.years && item.years.length > 0) {
                    cardsHtml += '<div style="font-size: 12px; color: #999;"><span style="color: #999; font-weight: 600;">Years:</span> ' + item.years.join(', ') + '</div>';
                }
                
                cardsHtml += '</div>';
            }
            
            cardsHtml += '</div>';
            
            const html = 
                                '<div style="margin-bottom: 20px;">' +
                '<input type="text" id="partner-search" placeholder="Search by contributor name..." style="width: 100%; padding: 12px; border: 2px solid #dee2e6; border-radius: 8px; font-size: 14px; transition: all 0.2s;" />' +
                '</div>' +
                '<div style="background: linear-gradient(135deg, #fff5f3 0%, #fffbf9 100%); border-left: 4px solid #E3836D; padding: 16px; border-radius: 8px; margin-bottom: 20px; display: flex; align-items: center; gap: 12px;">' +
                '<svg width="20" height="20" viewBox="0 0 24 24" fill="#E3836D" stroke="#E3836D" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>' +
                '<div style="line-height: 1.2;">' +
                '<div style="font-size: 14px; font-weight: 600; color: #333; margin-bottom: 2px;">Explore Partnerships</div>' +
                '<div style="font-size: 12px; color: #666;">Click any pairing to see all tracks they have in common</div>' +
                '</div></div>' +
                cardsHtml;
            
            document.getElementById('partners').innerHTML = html;
            
            // Add click event listener to partner cards
            document.querySelectorAll('.partner-card').forEach(card => {
                card.addEventListener('click', function() {
                    const c1 = this.getAttribute('data-c1');
                    const c2 = this.getAttribute('data-c2');
                    showOverlapDetails(c1, c2);
                });
            });
            
            // Add search functionality
            const searchInput = document.getElementById('partner-search');
            if (searchInput) {
                searchInput.addEventListener('input', function() {
                    const searchTerm = this.value.toLowerCase();
                    const cards = document.querySelectorAll('.partner-card');
                    
                    cards.forEach(card => {
                        const c1 = card.getAttribute('data-c1').toLowerCase();
                        const c2 = card.getAttribute('data-c2').toLowerCase();
                        
                        // Show card if search term matches either contributor
                        if (searchTerm === '' || c1.includes(searchTerm) || c2.includes(searchTerm)) {
                            card.style.display = '';
                        } else {
                            card.style.display = 'none';
                        }
                    });
                });
            }
        }
        
        function showContributorDetails(contributorName) {
            saveScrollPosition('contributors');
            window.scrollTo(0, 0);
            const contributorTracks = globalData.raw.filter(row => {
                const addedBy = normalize(row['Added By']);
                return addedBy === contributorName;
            });
            
            const years = {};
            contributorTracks.forEach(track => {
                const year = extractYearFromAddedAt(track['Added At']);
                if (year !== 'N/A') {
                    years[year] = true;
                }
            });
            const sortedYears = Object.keys(years).sort((a, b) => b - a);
            
            // Get top 5 artists for this contributor
            const artistCounts = globalData.contributorTopArtists[contributorName] || {};
            const topArtists = Object.entries(artistCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5);
            
            // Get top 5 genres for this contributor
            const genreCounts = globalData.contributorTopGenres[contributorName] || {};
            const topGenres = Object.entries(genreCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5);
            
            // Consolidate tracks by Track ID
            const consolidatedTracks = {};
            contributorTracks.forEach(track => {
                const trackId = track['Track ID'];
                if (!consolidatedTracks[trackId]) {
                    consolidatedTracks[trackId] = {
                        name: track['Track Name'],
                        artist: track['Artist Name(s)'],
                        addedAtDates: []
                    };
                }
                if (track['Added At']) {
                    consolidatedTracks[trackId].addedAtDates.push(track['Added At']);
                }
            });
            
            const consolidatedArray = Object.entries(consolidatedTracks).map(([trackId, track]) => {
                let earliestYear = 'N/A';
                let mostRecentDate = null;
                if (track.addedAtDates.length > 0) {
                    const yearsForTrack = track.addedAtDates
                        .map(date => extractYearFromAddedAt(date))
                        .filter(year => year !== 'N/A')
                        .map(year => parseInt(year))
                        .sort((a, b) => a - b);
                    if (yearsForTrack.length > 0) {
                        earliestYear = yearsForTrack[0].toString();
                    }
                    // Find most recent date
                    const sortedDates = track.addedAtDates.sort((a, b) => new Date(b) - new Date(a));
                    mostRecentDate = new Date(sortedDates[0]);
                }
                // Get ALL contributors for this track from the full dataset
                const allContributorsForTrack = new Set();
                globalData.raw.forEach(row => {
                    if (row['Track ID'] === trackId) {
                        allContributorsForTrack.add(row['Added By']);
                    }
                });
                const hasOtherContributors = allContributorsForTrack.size > 1;
                return [track.name, track.artist, trackId, earliestYear, mostRecentDate, hasOtherContributors, allContributorsForTrack.size];
            }).sort((a, b) => {
                // Primary sort: by number of contributors (descending)
                if (b[6] !== a[6]) return b[6] - a[6];
                // Secondary sort: by most recent date (descending)
                if (b[4] && a[4]) return b[4] - a[4];
                if (b[4]) return -1;
                if (a[4]) return 1;
                return 0;
            });
            
            const html = `
                <div style="margin-bottom: 20px;">
                    <button onclick="restoreScrollPosition('contributors'); renderContributors();" style="background: #F8F9FA; color: black; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 14px;">
<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline-block; margin-right: 8px; vertical-align: middle;">
    <line x1="19" y1="12" x2="5" y2="12"></line>
    <polyline points="12 19 5 12 12 5"></polyline>
</svg>
Back to All Contributors                    </button>
                </div>
                
                <h2 style="margin-bottom: 20px;">Tracks added by ${formatContributorWithName(contributorName)} (${consolidatedArray.length} unique tracks)</h2>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-bottom: 30px;">
                    <div class="chart-container">
                        <h3 style="margin-bottom: 15px; color: #E3836D;">Top 5 Artists</h3>
                        <div class="bar-chart">
                            ${topArtists.map(([artist, count]) => `
                                <div class="bar-item">
                                    <div class="bar-label" style="min-width: 120px; font-size: 13px;">${artist}</div>
                                    <div class="bar-wrapper" style="height: 25px;">
                                        <div class="bar-fill" style="width: ${(count / topArtists[0][1]) * 100}%; font-size: 11px;">${count}</div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                    
                    <div class="chart-container">
                        <h3 style="margin-bottom: 15px; color: #E3836D;">Top 5 Genres</h3>
                        <div class="bar-chart">
                            ${topGenres.map(([genre, count]) => `
                                <div class="bar-item">
                                    <div class="bar-label" style="min-width: 120px; font-size: 13px;">${genre}</div>
                                    <div class="bar-wrapper" style="height: 25px;">
                                        <div class="bar-fill" style="width: ${(count / topGenres[0][1]) * 100}%; font-size: 11px;">${count}</div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
                
                <div class="filter-buttons">
                    <button class="filter-btn active" onclick="filterContributorByYear('all')">All</button>
                    ${sortedYears.map(year => `
                        <button class="filter-btn" onclick="filterContributorByYear('${year}')">${year}</button>
                    `).join('')}
                </div>
                
                <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 20px;">
                    <label style="display: flex; align-items: center; gap: 12px; cursor: pointer; user-select: none;">
                        <div class="toggle-switch-container">
                            <input type="checkbox" id="other-contributors-filter" onchange="toggleOtherContributorsFilter()" class="toggle-switch-input">
                            <span class="toggle-switch-slider"></span>
                        </div>
                        <span style="font-size: 14px; color: #333;">Show only tracks also added by others</span>
                    </label>
                </div>
                
                <div class="search-box">
                    <input type="text" placeholder="Search tracks..." onkeyup="filterTrackCards(this.value)">
                </div>

                ${generateTrackCardsHTML(consolidatedArray)}
            `;
            
            document.getElementById('contributors').innerHTML = html;
            reinitializeLazyLoading();
        }
        
        function filterContributorByYear(year) {
            const cards = document.querySelectorAll('.track-card');
            const buttons = document.querySelectorAll('.filter-btn');
            const checkbox = document.getElementById('other-contributors-filter');
            
            buttons.forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            cards.forEach(card => {
                const cardYear = card.getAttribute('data-year');
                const hasOtherContributors = card.getAttribute('data-other-contributors') === 'true';
                
                let shouldShow = true;
                
                // Apply year filter
                if (year !== 'all' && cardYear !== year) {
                    shouldShow = false;
                }
                
                // Apply other contributors filter if checked
                if (checkbox && checkbox.checked && !hasOtherContributors) {
                    shouldShow = false;
                }
                
                card.style.display = shouldShow ? '' : 'none';
            });
        }
        
        function toggleOtherContributorsFilter() {
            const checkbox = document.getElementById('other-contributors-filter');
            if (!checkbox) return;
            
            const cards = document.querySelectorAll('.track-card');
            const activeButton = document.querySelector('.filter-btn.active');
            const currentYear = activeButton ? activeButton.textContent.trim() : 'All';
            
            console.log('Toggle filter - Checked:', checkbox.checked, 'Year:', currentYear, 'Total cards:', cards.length);
            
            cards.forEach(card => {
                // hasOtherContributors = true means this track was added by multiple contributors (including the current one)
                const hasOtherContributors = card.getAttribute('data-other-contributors') === 'true';
                const cardYear = card.getAttribute('data-year');
                
                let shouldShow = true;
                
                // Apply year filter
                if (currentYear !== 'All' && cardYear !== currentYear) {
                    shouldShow = false;
                }
                
                // Apply other contributors filter - only show if checked AND track has other contributors
                if (checkbox.checked && !hasOtherContributors) {
                    shouldShow = false;
                }
                
                card.style.display = shouldShow ? '' : 'none';
            });
        }
        
        function sortArtistTableByColumn(column) {
            const table = document.getElementById('artist-tracks-table');
            const tbody = table.getElementsByTagName('tbody')[0];
            const rows = Array.from(tbody.getElementsByTagName('tr'));
            const headers = table.getElementsByTagName('th');
            
            let clickedHeader = null;
            for (let i = 0; i < headers.length; i++) {
                if (headers[i].onclick && headers[i].onclick.toString().includes(column)) {
                    clickedHeader = headers[i];
                    break;
                }
            }
            
            let isAsc = true;
            if (clickedHeader) {
                if (clickedHeader.classList.contains('asc')) {
                    isAsc = false;
                    clickedHeader.classList.remove('asc');
                    clickedHeader.classList.add('desc');
                } else {
                    isAsc = true;
                    clickedHeader.classList.remove('desc');
                    clickedHeader.classList.add('asc');
                }
                
                for (let i = 0; i < headers.length; i++) {
                    if (headers[i] !== clickedHeader) {
                        headers[i].classList.remove('asc', 'desc');
                    }
                }
            }
            
            rows.sort((a, b) => {
                let valA, valB;
                
                if (column === 'track') {
                    valA = a.getAttribute('data-track').toLowerCase();
                    valB = b.getAttribute('data-track').toLowerCase();
                } else if (column === 'album') {
                    valA = a.getAttribute('data-album').toLowerCase();
                    valB = b.getAttribute('data-album').toLowerCase();
                } else if (column === 'release') {
                    valA = a.getAttribute('data-release');
                    valB = b.getAttribute('data-release');
                }
                
                if (isAsc) {
                    return valA.localeCompare(valB);
                } else {
                    return valB.localeCompare(valA);
                }
            });
            
rows.forEach((row) => {
    tbody.appendChild(row);
    const originalIndex = parseInt(row.getAttribute('data-original-index'));
    row.cells[0].textContent = originalIndex + 1;  // Uses original index
});
        }
        
        function sortAlbumTableByColumn(column) {
            const table = document.getElementById('album-tracks-table');
            const tbody = table.getElementsByTagName('tbody')[0];
            const rows = Array.from(tbody.getElementsByTagName('tr'));
            const headers = table.getElementsByTagName('th');
            
            let clickedHeader = null;
            for (let i = 0; i < headers.length; i++) {
                if (headers[i].onclick && headers[i].onclick.toString().includes(column)) {
                    clickedHeader = headers[i];
                    break;
                }
            }
            
            let isAsc = true;
            if (clickedHeader) {
                if (clickedHeader.classList.contains('asc')) {
                    isAsc = false;
                    clickedHeader.classList.remove('asc');
                    clickedHeader.classList.add('desc');
                } else {
                    isAsc = true;
                    clickedHeader.classList.remove('desc');
                    clickedHeader.classList.add('asc');
                }
                
                for (let i = 0; i < headers.length; i++) {
                    if (headers[i] !== clickedHeader) {
                        headers[i].classList.remove('asc', 'desc');
                    }
                }
            }
            
            rows.sort((a, b) => {
                let valA, valB;
                
                if (column === 'track') {
                    valA = a.getAttribute('data-track').toLowerCase();
                    valB = b.getAttribute('data-track').toLowerCase();
                } else if (column === 'artist') {
                    valA = a.getAttribute('data-artist').toLowerCase();
                    valB = b.getAttribute('data-artist').toLowerCase();
                } else if (column === 'release') {
                    valA = a.getAttribute('data-release');
                    valB = b.getAttribute('data-release');
                }
                
                if (isAsc) {
                    return valA.localeCompare(valB);
                } else {
                    return valB.localeCompare(valA);
                }
            });
            
rows.forEach((row) => {
    tbody.appendChild(row);
    const originalIndex = parseInt(row.getAttribute('data-original-index'));
    row.cells[0].textContent = originalIndex + 1;  // Uses original index
});
        }
        
        function sortGenreTableByColumn(column) {
            const table = document.getElementById('genre-tracks-table');
            const tbody = table.getElementsByTagName('tbody')[0];
            const rows = Array.from(tbody.getElementsByTagName('tr'));
            const headers = table.getElementsByTagName('th');
            
            // Find the header that was clicked
            let clickedHeader = null;
            for (let i = 0; i < headers.length; i++) {
                if (headers[i].onclick && headers[i].onclick.toString().includes(column)) {
                    clickedHeader = headers[i];
                    break;
                }
            }
            
            // Determine sort direction
            let isAsc = true;
            if (clickedHeader) {
                if (clickedHeader.classList.contains('asc')) {
                    isAsc = false;
                    clickedHeader.classList.remove('asc');
                    clickedHeader.classList.add('desc');
                } else {
                    isAsc = true;
                    clickedHeader.classList.remove('desc');
                    clickedHeader.classList.add('asc');
                }
                
                // Remove sort indicators from other headers
                for (let i = 0; i < headers.length; i++) {
                    if (headers[i] !== clickedHeader) {
                        headers[i].classList.remove('asc', 'desc');
                    }
                }
            }
            
            // Sort rows
            rows.sort((a, b) => {
                let valA, valB;
                
                if (column === 'track') {
                    valA = a.getAttribute('data-track').toLowerCase();
                    valB = b.getAttribute('data-track').toLowerCase();
                } else if (column === 'artist') {
                    valA = a.getAttribute('data-artist').toLowerCase();
                    valB = b.getAttribute('data-artist').toLowerCase();
                } else if (column === 'album') {
                    valA = a.getAttribute('data-album').toLowerCase();
                    valB = b.getAttribute('data-album').toLowerCase();
                } else if (column === 'release') {
                    valA = a.getAttribute('data-release').toLowerCase();
                    valB = b.getAttribute('data-release').toLowerCase();
                }
                
                if (isAsc) {
                    return valA.localeCompare(valB);
                } else {
                    return valB.localeCompare(valA);
                }
            });
            
rows.forEach((row) => {
    tbody.appendChild(row);
    const originalIndex = parseInt(row.getAttribute('data-original-index'));
    row.cells[0].textContent = originalIndex + 1;  // Uses original index
});
        }
        
        function sortContributorTableByColumn(column) {
            const table = document.getElementById('contributor-tracks-table');
            const tbody = table.getElementsByTagName('tbody')[0];
            const rows = Array.from(tbody.getElementsByTagName('tr'));
            const headers = table.getElementsByTagName('th');
            
            // Find the header that was clicked
            let clickedHeader = null;
            for (let i = 0; i < headers.length; i++) {
                if (headers[i].onclick && headers[i].onclick.toString().includes(column)) {
                    clickedHeader = headers[i];
                    break;
                }
            }
            
            // Determine sort direction
            let isAsc = true;
            if (clickedHeader) {
                if (clickedHeader.classList.contains('asc')) {
                    isAsc = false;
                    clickedHeader.classList.remove('asc');
                    clickedHeader.classList.add('desc');
                } else {
                    isAsc = true;
                    clickedHeader.classList.remove('desc');
                    clickedHeader.classList.add('asc');
                }
                
                // Remove sort indicators from other headers
                for (let i = 0; i < headers.length; i++) {
                    if (headers[i] !== clickedHeader) {
                        headers[i].classList.remove('asc', 'desc');
                    }
                }
            }
            
            // Sort rows
            rows.sort((a, b) => {
                let valA, valB;
                
                if (column === 'track') {
                    valA = a.getAttribute('data-track').toLowerCase();
                    valB = b.getAttribute('data-track').toLowerCase();
                } else if (column === 'artist') {
                    valA = a.getAttribute('data-artist').toLowerCase();
                    valB = b.getAttribute('data-artist').toLowerCase();
                } else if (column === 'album') {
                    valA = a.getAttribute('data-album').toLowerCase();
                    valB = b.getAttribute('data-album').toLowerCase();
                } else if (column === 'year') {
                    valA = a.getAttribute('data-year');
                    valB = b.getAttribute('data-year');
                }
                
                if (isAsc) {
                    return valA.localeCompare(valB);
                } else {
                    return valB.localeCompare(valA);
                }
            });
            
rows.forEach((row) => {
    tbody.appendChild(row);
    const originalIndex = parseInt(row.getAttribute('data-original-index'));
    row.cells[0].textContent = originalIndex + 1;  // Uses original index
});
        }
        
        function sortContributorTable() {
            const select = document.getElementById('contributorSortSelect');
            const sortBy = select.value;
            const table = document.getElementById('contributor-tracks-table');
            const tbody = table.getElementsByTagName('tbody')[0];
            const rows = Array.from(tbody.getElementsByTagName('tr'));
            
            if (sortBy === 'default') {
                // Sort by original index
                rows.sort((a, b) => {
                    return parseInt(a.getAttribute('data-original-index')) - parseInt(b.getAttribute('data-original-index'));
                });
            } else if (sortBy === 'track-az') {
                rows.sort((a, b) => {
                    const trackA = a.getAttribute('data-track').toLowerCase();
                    const trackB = b.getAttribute('data-track').toLowerCase();
                    return trackA.localeCompare(trackB);
                });
            } else if (sortBy === 'artist-az') {
                rows.sort((a, b) => {
                    const artistA = a.getAttribute('data-artist').toLowerCase();
                    const artistB = b.getAttribute('data-artist').toLowerCase();
                    return artistA.localeCompare(artistB);
                });
            } else if (sortBy === 'album-az') {
                rows.sort((a, b) => {
                    const albumA = a.getAttribute('data-album').toLowerCase();
                    const albumB = b.getAttribute('data-album').toLowerCase();
                    return albumA.localeCompare(albumB);
                });
            } else if (sortBy === 'year-desc') {
                rows.sort((a, b) => {
                    const yearA = a.getAttribute('data-year');
                    const yearB = b.getAttribute('data-year');
                    return yearB.localeCompare(yearA);
                });
            } else if (sortBy === 'year-asc') {
                rows.sort((a, b) => {
                    const yearA = a.getAttribute('data-year');
                    const yearB = b.getAttribute('data-year');
                    return yearA.localeCompare(yearB);
                });
            }
            
rows.forEach((row) => {
    tbody.appendChild(row);
    const originalIndex = parseInt(row.getAttribute('data-original-index'));
    row.cells[0].textContent = originalIndex + 1;  // Uses original index
});
        }

        function renderTimeline() {
            if (globalData.years.length === 0) {
                document.getElementById('timeline').innerHTML = `
                    <div class="empty-state">
                        <p style="font-size: 18px; color: #666;">No release date data found in CSV</p>
                        <p style="margin-top: 10px; font-size: 14px;">Make sure your CSV has a "Release Date" column with year information</p>
                    </div>
                `;
                return;
            }
            
            const sortedYears = globalData.years.sort((a, b) => parseInt(a[0]) - parseInt(b[0]));
            const sortedAddedYears = globalData.addedYears.sort((a, b) => parseInt(a[0]) - parseInt(b[0]));
            
            // Filter for pre-2018 years
            const pre2018Years = sortedYears.filter(([year]) => {
                const y = parseInt(year);
                return y <= 2017;
            });
            
            // Filter for recent years (2018-2024)
            const recentYears = sortedYears.filter(([year]) => {
                const y = parseInt(year);
                return y >= 2018 && y <= 2024;
            });
            
            let html = '';
            
            // Tracks by Added Year
            if (sortedAddedYears.length > 0) {
                html += '<h2 style="margin-bottom: 20px;">Tracks by Added Year</h2>';
                html += createLineGraph(sortedAddedYears, 'When Tracks Were Added', sortedAddedYears.length);
                html += '<div style="margin-top: 50px;"></div>';
            }
            
            // Recent years timeline (2018-2024)
            if (recentYears.length > 0) {
                html += '<h2 style="margin-bottom: 20px;">Tracks by Release Year</h2>';
                html += createLineGraph(recentYears, '2018 - 2024', recentYears.length);
            }
            
            // Pre-2018 timeline
            if (pre2018Years.length > 0) {
                if (recentYears.length > 0) {
                    html += '<div style="margin-top: 50px;"></div>';
                } else {
                    html += '<h2 style="margin-bottom: 20px;">Tracks by Release Year</h2>';
                }
                html += createLineGraph(pre2018Years, 'Up to 2017', pre2018Years.length);
            }
            
            // Year details table - reverse order (most recent first)
            const reversedYears = [...sortedYears].reverse();
            
            html += `
                <h3 style="margin-top: 40px; margin-bottom: 15px;">Release Year Details</h3>
                <div style="max-height: 400px; overflow-y: auto;">
                    <table>
                        <thead>
                            <tr>
                                <th>Year</th>
                                <th>Tracks</th>
                                <th>Percentage</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${reversedYears.map(([year, count]) => `
                                <tr>
                                    <td><strong>${year}</strong></td>
                                    <td>${count}</td>
                                    <td>${((count / globalData.raw.length) * 100).toFixed(1)}%</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            
            // Added year details table
            const reversedAddedYears = [...sortedAddedYears].reverse();
            
            html += `
                <h3 style="margin-top: 40px; margin-bottom: 15px;">Added Year Details</h3>
                <div style="max-height: 400px; overflow-y: auto;">
                    <table>
                        <thead>
                            <tr>
                                <th>Year</th>
                                <th>Tracks</th>
                                <th>Percentage</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${reversedAddedYears.map(([year, count]) => `
                                <tr>
                                    <td><strong>${year}</strong></td>
                                    <td>${count}</td>
                                    <td>${((count / globalData.raw.length) * 100).toFixed(1)}%</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            
            document.getElementById('timeline').innerHTML = html;
        }
        
        function createLineGraph(yearData, title, totalYears) {
            const maxCount = Math.max(...yearData.map(y => y[1]));
            
            const width = 1000;
            const height = 400;
            const padding = 60;
            const graphWidth = width - padding * 2;
            const graphHeight = height - padding * 2;
            
            const points = yearData.map((year, i) => {
                const x = padding + (i / (yearData.length - 1)) * graphWidth;
                const y = padding + graphHeight - (year[1] / maxCount) * graphHeight;
                return { x, y, year: year[0], count: year[1] };
            });
            
            const pathData = points.map((p, i) => 
                `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`
            ).join(' ');
            
            const areaData = `M ${points[0].x} ${padding + graphHeight} L ${points.map(p => `${p.x} ${p.y}`).join(' L ')} L ${points[points.length - 1].x} ${padding + graphHeight} Z`;
            
            const labelInterval = Math.max(1, Math.floor(points.length / 15));
            
            return `
                <h2 style="margin-bottom: 20px;">Tracks by Release Year - ${title} (${totalYears} years)</h2>
                <div class="chart-container">
                    <svg viewBox="0 0 ${width} ${height}" style="width: 100%; height: auto;">
                        ${Array.from({length: 6}, (_, i) => {
                            const y = padding + (i / 5) * graphHeight;
                            const value = Math.round(maxCount * (1 - i / 5));
                            return `
                                <line x1="${padding}" y1="${y}" x2="${width - padding}" y2="${y}" stroke="#e0e0e0" stroke-width="1"/>
                                <text x="${padding - 10}" y="${y + 5}" text-anchor="end" fill="#999" font-size="12">${value}</text>
                            `;
                        }).join('')}
                        
                        <path d="${areaData}" fill="url(#gradient)" opacity="0.3"/>
                        
                        <path d="${pathData}" fill="none" stroke="url(#gradient)" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
                        
                        ${points.map(p => `
                            <circle cx="${p.x}" cy="${p.y}" r="5" fill="#667eea" stroke="white" stroke-width="2">
                                <title>${p.year}: ${p.count} tracks</title>
                            </circle>
                        `).join('')}
                        
                        ${points.filter((_, i) => i % labelInterval === 0 || i === points.length - 1).map(p => `
                            <text x="${p.x}" y="${height - padding + 20}" text-anchor="middle" fill="#666" font-size="12">${p.year}</text>
                        `).join('')}
                        
                        <text x="${padding / 2}" y="${padding - 20}" text-anchor="middle" fill="#666" font-size="14" font-weight="bold">Tracks</text>
                        
                        <defs>
                            <linearGradient id="gradient" x1="0%" y1="0%" x2="100%" y2="0%">
                                <stop offset="0%" style="stop-color:#E3836D;stop-opacity:1" />
                                <stop offset="100%" style="stop-color:#E3836D;stop-opacity:1" />
                            </linearGradient>
                        </defs>
                    </svg>
                </div>
            `;
        }

        function filterTable(input, tableId) {
    const filter = input.value.toLowerCase();
    
    // If searching playlist cards
    if (tableId === 'playlists-table') {
        const cards = document.querySelectorAll('.card');
        cards.forEach(card => {
            const title = card.querySelector('.card-title')?.textContent.toLowerCase() || '';
            const creator = card.querySelector('.card-creator')?.textContent.toLowerCase() || '';
            
            const found = title.includes(filter) || creator.includes(filter);
            card.style.display = found ? '' : 'none';
        });
    } else {
        // Keep existing table search logic for other tabs
        const table = document.getElementById(tableId);
        const rows = table.getElementsByTagName('tr');
        
        for (let i = 1; i < rows.length; i++) {
            const cells = rows[i].getElementsByTagName('td');
            let found = false;
            for (let j = 0; j < cells.length; j++) {
                if (cells[j].textContent.toLowerCase().includes(filter)) {
                    found = true;
                    break;
                }
            }
            rows[i].style.display = found ? '' : 'none';
        }
    }
}
        
        function filterOverlapByYear(year) {
            // This function is deprecated - year filtering was removed from Partners tab
            // Kept for backwards compatibility
        }
        
        function showOverlapDetails(c1, c2) {
            saveScrollPosition('partners');
            window.scrollTo(0, 0);
            
            // Get all tracks by each contributor
            const c1Tracks = new Set();
            const c2Tracks = new Set();
            
            globalData.raw.forEach(row => {
                const trackId = row['Track ID'];
                if (normalize(row['Added By']) === c1) {
                    c1Tracks.add(trackId);
                }
                if (normalize(row['Added By']) === c2) {
                    c2Tracks.add(trackId);
                }
            });
            
            // Find shared tracks
            const sharedTrackIds = [...c1Tracks].filter(t => c2Tracks.has(t));
            
            // Build consolidated track array
            const consolidatedArray = [];
            const seen = {};
            
            sharedTrackIds.forEach(trackId => {
                if (!seen[trackId]) {
                    seen[trackId] = true;
                    
                    // Get track data from first matching row in raw data
                    const trackRow = globalData.raw.find(row => row['Track ID'] === trackId);
                    if (trackRow) {
                        const year = extractYearFromAddedAt(trackRow['Added At']);
                        
                        // Check if other contributors also added this track
                        const allContributorsForTrack = new Set();
                        globalData.raw.forEach(row => {
                            if (row['Track ID'] === trackId) {
                                allContributorsForTrack.add(row['Added By']);
                            }
                        });
                        const hasOtherContributors = allContributorsForTrack.size > 1;
                        
                        consolidatedArray.push([
                            trackRow['Track Name'],
                            trackRow['Artist Name(s)'],
                            trackId,
                            year,
                            year,
                            hasOtherContributors
                        ]);
                    }
                }
            });
            
            // Sort by year descending (most recent first)
            consolidatedArray.sort((a, b) => {
                const yearA = a[3] === 'N/A' ? 0 : parseInt(a[3]);
                const yearB = b[3] === 'N/A' ? 0 : parseInt(b[3]);
                return yearB - yearA;
            });
            
            // Format contributor names for display
            const c1Parts = c1.split('.');
            let c1FirstName = c1Parts[0] ? c1Parts[0].charAt(0).toUpperCase() + c1Parts[0].slice(1) : '';
            let c1LastName = c1Parts[1] ? c1Parts[1].charAt(0).toUpperCase() + c1Parts[1].slice(1) : '';
            if (c1 === 'trey.mcmillon') { c1FirstName = 'Trey'; c1LastName = 'McMillon'; }
            const c1DisplayName = c1LastName ? `${c1FirstName} ${c1LastName}` : c1FirstName;
            
            const c2Parts = c2.split('.');
            let c2FirstName = c2Parts[0] ? c2Parts[0].charAt(0).toUpperCase() + c2Parts[0].slice(1) : '';
            let c2LastName = c2Parts[1] ? c2Parts[1].charAt(0).toUpperCase() + c2Parts[1].slice(1) : '';
            if (c2 === 'trey.mcmillon') { c2FirstName = 'Trey'; c2LastName = 'McMillon'; }
            const c2DisplayName = c2LastName ? `${c2FirstName} ${c2LastName}` : c2FirstName;
            
            const c1Color = getContributorColor(c1);
            const c2Color = getContributorColor(c2);
            const c1Initials = c1Parts[0][0].toUpperCase() + (c1Parts[1] ? c1Parts[1][0].toUpperCase() : '');
            const c2Initials = c2Parts[0][0].toUpperCase() + (c2Parts[1] ? c2Parts[1][0].toUpperCase() : '');
            
            const html = `
                <div style="margin-bottom: 20px;">
                    <button onclick="restoreScrollPosition('partners'); renderPartners();" style="background: #F8F9FA; color: black; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 14px;">
<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline-block; margin-right: 8px; vertical-align: middle;">
    <line x1="19" y1="12" x2="5" y2="12"></line>
    <polyline points="12 19 5 12 12 5"></polyline>
</svg>
Back to Partners                    </button>
                </div>
                
                <div style="background: linear-gradient(90deg, ${c1Color}30, ${c2Color}30); padding: 20px; border-radius: 12px; margin-bottom: 24px;">
                    <div style="display: flex; align-items: center; justify-content: center; gap: 0; margin-bottom: 16px; position: relative; height: 50px;">
                        <!-- First badge -->
                        <div style="width: 50px; height: 50px; border-radius: 50%; background: ${c1Color}; color: white; display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 16px; flex-shrink: 0; border: 3px solid white; position: relative; z-index: 2; box-shadow: 0 2px 8px rgba(0,0,0,0.15);">${c1Initials}</div>
                        <!-- Second badge (overlapped) -->
                        <div style="width: 50px; height: 50px; border-radius: 50%; background: ${c2Color}; color: white; display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 16px; flex-shrink: 0; border: 3px solid white; position: relative; z-index: 1; margin-left: -15px; box-shadow: 0 2px 8px rgba(0,0,0,0.15);">${c2Initials}</div>
                    </div>
                    <div style="display: flex; align-items: center; justify-content: center; gap: 12px; flex-wrap: wrap;" class="partnership-header-names">
                        <div style="text-align: center; flex-basis: 100%; min-width: 0;">
                            <div style="font-size: 14px; font-weight: 600; color: #333; display: inline-block; white-space: nowrap;">${c1DisplayName}</div>
                            <div style="display: inline; white-space: nowrap;">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#999" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" style="display: inline-block; margin: 0 12px; vertical-align: middle;">
                                    <line x1="12" y1="5" x2="12" y2="19"></line>
                                    <line x1="5" y1="12" x2="19" y2="12"></line>
                                </svg>
                            </div>
                            <div style="display: inline-block; white-space: nowrap;">
                                <div style="font-size: 14px; font-weight: 600; color: #333; display: inline;">${c2DisplayName}</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <h2 style="margin-bottom: 20px;">Shared Tracks (${consolidatedArray.length})</h2>
                
                <div class="search-box">
                    <input type="text" placeholder="Search shared tracks..." onkeyup="filterTrackCards(this.value)">
                </div>

                ${generateTrackCardsHTML(consolidatedArray)}
            `;
            
            document.getElementById('partners').innerHTML = html;
            reinitializeLazyLoading();
        }
        
        function showPlaylistDetails(playlistURI) {
            saveScrollPosition('playlists');
            const playlist = globalData.playlists ? globalData.playlists.find(p => p.uri === playlistURI) : null;
            
            if (!playlist) {
                document.getElementById('playlists').innerHTML = '<p>Playlist not found</p>';
                return;
            }
            
            const playlistTracks = globalData.raw.filter(row => {
                return row['Playlist URI'] === playlistURI;
            });
            
            const consolidatedTracks = {};
            playlistTracks.forEach(track => {
                const trackId = track['Track ID'];
                if (!consolidatedTracks[trackId]) {
                    consolidatedTracks[trackId] = {
                        name: track['Track Name'],
                        artist: track['Artist Name(s)'],
                        album: track['Album Name'],
                        releaseDate: track['Release Date'],
                        addedAt: track['Added At'],
                        contributors: [],
                        dates: []
                    };
                }
                const contributor = track['Added By'];
                if (contributor && !consolidatedTracks[trackId].contributors.includes(contributor)) {
                    consolidatedTracks[trackId].contributors.push(contributor);
                }
                if (track['Added At']) {
                    consolidatedTracks[trackId].dates.push(new Date(track['Added At']));
                }
            });
            
            const consolidatedArray = Object.values(consolidatedTracks).sort((a, b) => {
                // Primary sort: by number of contributors (descending)
                if (b.contributors.length !== a.contributors.length) return b.contributors.length - a.contributors.length;
                // Secondary sort: by most recent date (descending)
                const aDate = a.dates.length > 0 ? new Date(Math.max(...a.dates.map(d => d.getTime()))) : new Date(0);
                const bDate = b.dates.length > 0 ? new Date(Math.max(...b.dates.map(d => d.getTime()))) : new Date(0);
                return bDate - aDate;
            });
            const playlistId = playlist.uri.split(':').pop();
            const spotifyUrl = `https://open.spotify.com/playlist/${playlistId}`;
            
            const html = `
                <div style="margin-bottom: 20px;">
                    <button onclick="restoreScrollPosition('playlists'); renderPlaylists();" style="background: #F8F9FA; color: black; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 14px;">
<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline-block; margin-right: 8px; vertical-align: middle;">
    <line x1="19" y1="12" x2="5" y2="12"></line>
    <polyline points="12 19 5 12 12 5"></polyline>
</svg>
Back to All Playlists
                    </button>
                    <a href="${spotifyUrl}" target="_blank" rel="noopener noreferrer" style="background: var(--accent-color); color: white; text-decoration: none; padding: 10px 20px; border-radius: 6px; font-size: 14px; font-weight: 600; display: inline-block; margin-left: 10px;">
                        Open in Spotify 🎵
                    </a>
                </div>
                
                <h2 style="margin-bottom: 20px;">Tracks in "${playlist.name}" (${consolidatedArray.length} unique tracks)</h2>
                
                <div class="search-box">
                    <input type="text" placeholder="Search tracks..." onkeyup="filterTable(this, 'playlist-tracks-table')">
                </div>
                
                <table id="playlist-tracks-table">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th class="sortable" onclick="sortPlaylistTracksTableByColumn('track')">Track Name</th>
                            <th class="sortable" onclick="sortPlaylistTracksTableByColumn('artist')">Artist(s)</th>
                            <th class="sortable" onclick="sortPlaylistTracksTableByColumn('album')">Album</th>
                            <th class="sortable" onclick="sortPlaylistTracksTableByColumn('release')">Release Date</th>
                            <th>Added By</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${consolidatedArray.map((track, idx) => {
                            const contributorBadges = track.contributors.map(c => formatContributorBadge(c)).join(' ');
                            return `
                                <tr data-track="${track.name}" data-artist="${track.artist}" data-album="${track.album || ''}" data-release="${parseDateForSorting(track.releaseDate)}" data-original-index="${idx}">
                                    <td>${idx + 1}</td>
                                    <td><strong>${track.name}</strong></td>
                                    <td style="font-size: 13px; color: #666;">${track.artist}</td>
                                    <td style="font-size: 13px; color: #666;">${track.album || 'N/A'}</td>
                                    <td style="font-size: 13px; color: #666;">${formatDate(track.releaseDate)}</td>
                                    <td style="font-size: 11px;">${contributorBadges || 'N/A'}</td>
                                </tr>
                            `;
                        }).join('')}
                    </tbody>
                </table>
            `;
            
            document.getElementById('playlists').innerHTML = html;
        }
        
        function sortPlaylistTracksTableByColumn(column) {
            const table = document.getElementById('playlist-tracks-table');
            if (!table) return;
            
            const tbody = table.getElementsByTagName('tbody')[0];
            const rows = Array.from(tbody.getElementsByTagName('tr'));
            const headers = table.getElementsByTagName('th');
            
            let clickedHeader = null;
            for (let i = 0; i < headers.length; i++) {
                if (headers[i].onclick && headers[i].onclick.toString().includes(column)) {
                    clickedHeader = headers[i];
                    break;
                }
            }
            
            let isAsc = true;
            if (clickedHeader) {
                if (clickedHeader.classList.contains('asc')) {
                    isAsc = false;
                    clickedHeader.classList.remove('asc');
                    clickedHeader.classList.add('desc');
                } else {
                    isAsc = true;
                    clickedHeader.classList.remove('desc');
                    clickedHeader.classList.add('asc');
                }
                
                for (let i = 0; i < headers.length; i++) {
                    if (headers[i] !== clickedHeader) {
                        headers[i].classList.remove('asc', 'desc');
                    }
                }
            }
            
            rows.sort((a, b) => {
                let valA = '';
                let valB = '';
                
                if (column === 'track') {
                    valA = (a.getAttribute('data-track') || '').toLowerCase();
                    valB = (b.getAttribute('data-track') || '').toLowerCase();
                } else if (column === 'artist') {
                    valA = (a.getAttribute('data-artist') || '').toLowerCase();
                    valB = (b.getAttribute('data-artist') || '').toLowerCase();
                } else if (column === 'album') {
                    valA = (a.getAttribute('data-album') || '').toLowerCase();
                    valB = (b.getAttribute('data-album') || '').toLowerCase();
                } else if (column === 'release') {
                    valA = a.getAttribute('data-release') || '0000-00-00';
                    valB = b.getAttribute('data-release') || '0000-00-00';
                }
                
                if (isAsc) {
                    return valA.localeCompare(valB);
                } else {
                    return valB.localeCompare(valA);
                }
            });
            
rows.forEach((row) => {
    tbody.appendChild(row);
    const originalIndex = parseInt(row.getAttribute('data-original-index'));
    row.cells[0].textContent = originalIndex + 1;  // Uses original index
});
        }
function toggleMobileMenu(evt) {
    // Prevent the global document click handler from immediately closing the dropdown
    if (evt && evt.stopPropagation) evt.stopPropagation();

    const dropdown = document.getElementById('mobileDropdown');
    const menuBtn = document.querySelector('.mobile-menu-btn');

    if (!dropdown) return;

    const isOpen = dropdown.classList.contains('open');

    if (isOpen) {
        dropdown.classList.remove('open');
        dropdown.classList.add('hidden');
        if (menuBtn) {
            menuBtn.classList.remove('open');
            menuBtn.setAttribute('aria-expanded', 'false');
        }
    } else {
        dropdown.classList.remove('hidden');
        dropdown.classList.add('open');
        if (menuBtn) {
            menuBtn.classList.add('open');
            menuBtn.setAttribute('aria-expanded', 'true');
        }
    }
}

function switchTabMobile(tabName, evt) {
    // Prevent the click from bubbling up and triggering the outside-click closer
    if (evt && evt.stopPropagation) evt.stopPropagation();

    switchTab(tabName);
    
    // Update active state in dropdown
    const buttons = document.querySelectorAll('.dropdown-menu button');
    buttons.forEach(btn => btn.classList.remove('active'));
    
    // Mark current tab as active
    if (evt && evt.target) {
        const btn = evt.target.closest('button');
        if (btn) btn.classList.add('active');
    }
    
    // Close dropdown after selection
    const dropdown = document.getElementById('mobileDropdown');
    if (dropdown) {
        dropdown.classList.add('hidden');
        dropdown.classList.remove('open');
    }
    const menuBtn = document.querySelector('.mobile-menu-btn');
    if (menuBtn) menuBtn.classList.remove('open');
    if (menuBtn) menuBtn.setAttribute('aria-expanded', 'false');
}

// Close dropdown when clicking outside
document.addEventListener('click', function(event) {
    const dropdown = document.getElementById('mobileDropdown');
    const menuBtn = document.querySelector('.mobile-menu-btn');
    
    if (dropdown && !dropdown.contains(event.target) && !menuBtn.contains(event.target)) {
        dropdown.classList.add('hidden');
        if (menuBtn) menuBtn.classList.remove('open');
    }
});

// Add touch feedback for contributor cards on mobile
document.addEventListener('touchstart', function(e) {
    const card = e.target.closest('.contributor-card');
    if (card) {
        card.classList.add('touch-active');
    }
}, { passive: true });

document.addEventListener('touchend', function(e) {
    const card = e.target.closest('.contributor-card');
    if (card) {
        card.classList.remove('touch-active');
    }
}, { passive: true });

document.addEventListener('touchcancel', function(e) {
    const card = e.target.closest('.contributor-card');
    if (card) {
        card.classList.remove('touch-active');
    }
}, { passive: true });

// Add touch feedback for track cards on mobile
document.addEventListener('touchstart', function(e) {
    const card = e.target.closest('.track-card');
    if (card) {
        card.classList.add('touch-active');
    }
}, { passive: true });

document.addEventListener('touchend', function(e) {
    const card = e.target.closest('.track-card');
    if (card) {
        card.classList.remove('touch-active');
    }
}, { passive: true });

document.addEventListener('touchcancel', function(e) {
    const card = e.target.closest('.track-card');
    if (card) {
        card.classList.remove('touch-active');
    }
}, { passive: true });

// Initialize on page load
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', loadCSVFromGitHub);
} else {
    loadCSVFromGitHub();
}

function showContributorTooltip(event) {
    const badge = event.target;
    const contributorName = badge.getAttribute('data-contributor');
    
    // Remove any existing tooltip
    const existingTooltip = document.querySelector('.contributor-tooltip');
    if (existingTooltip) {
        existingTooltip.remove();
    }
    
    // Create tooltip element
    const tooltip = document.createElement('div');
    tooltip.className = 'contributor-tooltip';
    tooltip.textContent = contributorName;
    tooltip.style.cssText = `
        position: fixed;
        background: #333;
        color: white;
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 600;
        z-index: 1000;
        pointer-events: none;
        white-space: nowrap;
    `;
    
    document.body.appendChild(tooltip);
    
    // Position tooltip above the badge
    const rect = badge.getBoundingClientRect();
    tooltip.style.left = (rect.left + rect.width / 2 - tooltip.offsetWidth / 2) + 'px';
    tooltip.style.top = (rect.top - tooltip.offsetHeight - 8) + 'px';
    
    // Remove tooltip after 2 seconds
    setTimeout(() => {
        tooltip.remove();
    }, 2000);
}
    </script>
</body>
</html>        